using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Reloaded.Memory.Buffers.Internal.Structs;
using Reloaded.Memory.Buffers.Internal.Utilities;
using Reloaded.Memory.Sources;

namespace Reloaded.Memory.Buffers.Internal
{
    /// <summary>
    /// Creates <see cref="MemoryBuffer"/>s in unmanaged memory and returns a new instance to the user.
    /// </summary>
    internal static unsafe class MemoryBufferFactory
    {
        /// <summary> Calculates the overhead of each individual buffer.</summary>
        internal static int BufferOverhead => sizeof(MemoryBufferProperties) + sizeof(MemoryBufferMagic);

        /// <summary> Calculates the overhead of each individual private buffer.</summary>
        internal static int PrivateBufferOverhead => sizeof(MemoryBufferProperties);

        /// <summary> Pregenerated byte sequence used to identify a Reloaded buffer. </summary>
        private static MemoryBufferMagic _bufferMagic = new MemoryBufferMagic(true);

        /// <summary>
        /// Creates a new buffer in a specified location in memory with a specified size.
        /// </summary>
        /// <param name="process">The process inside which the <see cref="MemoryBuffer"/> will be allocated.</param>
        /// <param name="bufferAddress">Base address of the new buffer to be created. </param>
        /// <param name="allocationSize">The amount of bytes allocated at bufferAddress</param>
        /// <param name="allocateMemory">Set this to false if the allocationSize bytes have already been preallocated at bufferAddress.</param>
        /// <remarks>
        /// This constructor will override any existing buffer! Please use <see cref="MemoryBufferFactory.FromAddress"/> instead
        /// if you wish to get a hold of an already existing buffer at the given bufferAddress.
        /// </remarks>
        internal static MemoryBuffer CreateBuffer(Process process, nuint bufferAddress, int allocationSize, bool allocateMemory = true)
        {
            if (allocateMemory)
                AllocateBuffer(process, bufferAddress, allocationSize);

            var memorySource = GetMemorySource(process);

            // Write buffer "magic".
            memorySource.Write(bufferAddress, ref _bufferMagic);

            // Setup buffer after Magic.
            var headerAddress      = (UIntPtr)bufferAddress + sizeof(MemoryBufferMagic);
            var dataPtr            = (UIntPtr)bufferAddress + BufferOverhead;
            var realBufSize        = allocationSize - BufferOverhead;
            var memoryBufferProperties = new MemoryBufferProperties(dataPtr, realBufSize);

            var buffer = new MemoryBuffer(memorySource, headerAddress, memoryBufferProperties);
            buffer.SetupMutex(process);
            return buffer;
        }

        /// <summary>
        /// Creates a new private <see cref="MemoryBuffer"/> in a specified location in memory with a specified size.
        /// </summary>
        internal static PrivateMemoryBuffer CreatePrivateBuffer(Process process, nuint bufferAddress, int allocationSize, bool allocateMemory = true)
        {
            if (allocateMemory)
                AllocateBuffer(process, bufferAddress, allocationSize);

            var memorySource = GetMemorySource(process);

            // Setup buffer after Magic.
            var dataPtr = (UIntPtr)bufferAddress + PrivateBufferOverhead;
            var realBufSize = allocationSize - PrivateBufferOverhead;
            var memoryBufferProperties = new MemoryBufferProperties(dataPtr, realBufSize);

            var buffer = new PrivateMemoryBuffer(memorySource, bufferAddress, memoryBufferProperties);
            buffer.SetupMutex(process);
            return buffer;
        }

        /// <summary>
        /// Attempts to find an existing <see cref="MemoryBuffer"/> at the specified address and returns an instance of it.
        /// If the operation fails; the function returns null.
        /// </summary>
        internal static unsafe MemoryBuffer FromAddress(Process process, nuint bufferMagicAddress)
        {
            // Query the region we are going to create a buffer in.
            var virtualQueryFunction = VirtualQueryUtility.GetVirtualQueryFunction(process);
            var memoryInformation = new Kernel32.Kernel32.MEMORY_BASIC_INFORMATION();
            var result = virtualQueryFunction(process.Handle, bufferMagicAddress, ref memoryInformation);
            if (result == (UIntPtr) 0)
                throw new Exception("VirtualQuery failed. Result is 0.");

            if (memoryInformation.State != (uint)Memory.Kernel32.Kernel32.MEM_ALLOCATION_TYPE.MEM_FREE)
            {
                if (IsBuffer(process, bufferMagicAddress))
                {
                    var buffer = new MemoryBuffer(GetMemorySource(process), (UIntPtr) bufferMagicAddress + sizeof(MemoryBufferMagic));
                    buffer.SetupMutex(process);
                    return buffer;
                }
            }

            return null;
        }

        /// <summary>
        /// Allocates memory to store a <see cref="MemoryBuffer"/>s inside the target process/
        /// </summary>
        internal static void AllocateBuffer(Process process, nuint bufferAddress, int bufferSize)
        {
            // Get the function, commit the pages and check.
            var virtualAllocFunction = VirtualAllocUtility.GetVirtualAllocFunction(process);
            var address = virtualAllocFunction(process.Handle, bufferAddress, (uint)bufferSize);

            if (address == UIntPtr.Zero)
                throw new Exception($"Failed to allocate MemoryBuffer of size {bufferSize} at address {bufferAddress}. Last Win32 Error: {Marshal.GetLastWin32Error()}");
        }

        /// <summary>
        /// Retrieves the correct <see cref="IMemory"/> implementation to access the memory of a given
        /// process.
        /// </summary>
        internal static IMemory GetMemorySource(Process process)
        {
            if (process.Id == Process.GetCurrentProcess().Id)
                return new Sources.Memory();
            else
                return new ExternalMemory(process);
        }

        /// <summary>
        /// Checks if a <see cref="MemoryBuffer"/> exists at this location by comparing the bytes available here
        /// against the MemoryBuffer "Magic".
        /// </summary>
        internal static bool IsBuffer(Process process, nuint bufferMagicAddress)
        {
            try
            {
                GetMemorySource(process).SafeRead(bufferMagicAddress, out MemoryBufferMagic bufferMagic);

                if (_bufferMagic.MagicEquals(ref bufferMagic))
                    return true;
            }
            catch {  /* Suppress */ }

            return false;
        }
    }
}
