{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Reloaded Buffers Library Allocate Memory, &amp; Knuckles"},{"location":"#about","title":"About","text":"<p><code>Reloaded.Memory.Buffers</code> is a library for allocating memory between a given minimum and maximum memory address, for C# and Rust</p> <p>With the following properties:</p> <ul> <li>Memory Efficient: No wasted memory.  </li> <li>Shared: Can be found and read/written to by multiple users.  </li> <li>Static: Allocated data never moves, or is overwritten.  </li> <li>Permanent: Allocated data lasts the lifetime of the process.  </li> <li>Concurrent: Multiple users can access at the same time.  </li> <li>Large Address Aware: On Windows, the library can correctly leverage all 4GB in 32-bit processes.  </li> <li>Cross Platform: Supports Windows, OSX and Linux.  </li> </ul> <p>Note: Rust/C port also works with FreeBSD (untested), and has partial (limited) Android support.</p>"},{"location":"#example-use-cases","title":"Example Use Cases","text":"<p>These are just examples.</p> <ul> <li>Hooks: Hooking libraries like Reloaded.Hooks can reduce amount of bytes stolen from functions.  </li> <li>Libraries: Libraries like Reloaded.Assembler require memory be allocated in first 2GB for x64 FASM.  </li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>The library provides a simple high level API to use.</p> <p>Both C# and Rust ports expose the same APIs.</p>"},{"location":"#get-a-buffer","title":"Get A Buffer","text":"<p>Gets a buffer where you can allocate 4096 bytes in first 2GiB of address space.</p> C#RustC/C++ <pre><code>var settings = new BufferSearchSettings()\n{\n    MinAddress = 0,\n    MaxAddress = int.MaxValue,\n    Size = 4096\n};\n\n// Make sure to dispose, so lock gets released.\nusing var item = Buffers.GetBuffer(settings);\n\n// Write some data, get pointer back.\nvar ptr = item-&gt;Append(data); \n</code></pre> <pre><code>let settings = BufferSearchSettings {\n    min_address: 0 as usize,\n    max_address: i32::MAX as usize,\n    size: 4096,\n};\n\n// Automatically dropped.\nlet item = Buffers::get_buffer(&amp;settings)?;\n\n// Append some data.\nunsafe {\n    item.append_bytes(data);\n}\n</code></pre> <pre><code>BufferSearchSettings settings;\nsettings.MinAddress = 0;\nsettings.MaxAddress = INT_MAX;\nsettings.Size = 4096;\n\n// Automatically dropped.\nGetBufferResult result = buffers_get_buffer(&amp;settings);\n\n// Append some data.\nunsigned char data[4096] = {0}; // some data from heap, or something :wink:\nif (result.IsOk) {\n    locatoritem_append_bytes(result.Ok, data, sizeof(data));\n    free_get_buffer_result(result);\n}\n</code></pre>"},{"location":"#get-a-buffer-with-proximity","title":"Get A Buffer (With Proximity)","text":"<p>Gets a buffer where 4096 bytes written will be within 2GiB of 0x140000000.</p> C#RustC/C++ <pre><code>var settings = BufferSearchSettings.FromProximity(int.MaxValue, (nuint)0x140000000, 4096);\n\n// Make sure to dispose, so lock gets released.\nusing var item = Buffers.GetBuffer(settings);\n\n// Write some data, get pointer back.\nvar ptr = item-&gt;Append(data); \n</code></pre> <pre><code>let settings = BufferSearchSettings::from_proximity(i32::MAX, 0x140000000 as usize, 4096);\n\n// Automatically dropped.\nlet item = Buffers::get_buffer(settings)?;\n\n// Append some data.\nunsafe {\n    item?.append_bytes(data);\n}\n</code></pre> <pre><code>// Get the buffer\nBufferSearchSettings settings = buffersearchsettings_from_proximity(INT32_MAX, base_address, SIZE);\nGetBufferResult result = buffers_get_buffer(&amp;settings);\n\n// Append some data.\nlocatoritem_append_bytes(result.Ok, &amp;data[0], data.Length);\n\n// Dispose\nfree_get_buffer_result(result);\n</code></pre> <p>Use <code>append_code</code> instead of <code>append_bytes</code> if you need to add executable code. (Currently unavailable in C# port)</p>"},{"location":"#allocate-memory","title":"Allocate Memory","text":"<p>Allows you to temporarily allocate memory within a specific address range and size constraints.</p> C#RustC/C++ <pre><code>// Arrange\nvar settings = new BufferAllocatorSettings()\n{\n    MinAddress = 0,\n    MaxAddress = int.MaxValue,\n    Size = 4096\n};\n\nusing var item = Buffers.AllocatePrivateMemory(settings);\n\n// You have allocated memory in first 2GiB of address space.\n// Disposing this memory (via `using` statement) will free it.\nitem.BaseAddress.Should().NotBeNull();\nitem.Size.Should().BeGreaterOrEqualTo(settings.Size);\n</code></pre> <pre><code>let mut settings = BufferAllocatorSettings::new();\nsettings.min_address = 0;\nsettings.max_address = i32::MAX as usize;\nsettings.size = 4096;\n\nlet item = Buffers::allocate_private_memory(&amp;mut settings).unwrap();\n\n// You have allocated memory in first 2GiB of address space.\nassert!(item.base_address.as_ptr() != std::ptr::null_mut());\nassert!(item.size &gt;= settings.size as usize);\n</code></pre> <pre><code>BufferSearchSettings settings;\nsettings.MinAddress = 0;\nsettings.MaxAddress = INT_MAX;\nsettings.Size = 4096;\n\nAllocationResult item = allocate_private_memory(&amp;mut settings);\n\n// You have allocated memory in first 2GiB of address space.\n</code></pre> <p>You can specify another process with <code>TargetProcess = someProcess</code> in <code>BufferAllocatorSettings</code>, but this is only supported on Windows.</p>"},{"location":"#overwriting-allocated-instructions","title":"Overwriting Allocated Instructions","text":"<p>On non-x86 architectures, some extra actions may be needed when overwriting executable code allocated with <code>append_code</code>.</p> <p>This involves clearing instruction cache, and abiding by Write XOR Execute restrictions.</p> RustC/C++ <pre><code>Self::overwrite_allocated_code(source, target, size);\nSelf::overwrite_allocated_code_ex(source, target, size, |src, tgt, sz| {\n    // Do stuff with executable code \n});\n</code></pre> <pre><code>void do_stuff_with_executable_code(char* source, char* target, size_t size) {\n    // Modify executable code in buffer\n}\n\noverwrite_allocated_code(source, target, size);\noverwrite_allocated_code_ex(source, target, size, do_stuff_with_executable_code);\n</code></pre> <p>Alternative overload also allows you to pass a 'context' variable.</p> <p>Not currently available in C# version. Submit an issue request or PR if you need this.</p>"},{"location":"#crate-features-rust","title":"Crate Features (Rust)","text":"<ul> <li><code>std</code>: [Enabled by Default] Enables use of standard library.   </li> <li><code>external_processes</code>: Support external processes (windows only).  </li> <li><code>no_format</code>: Disables formatting code in errors, saving ~8kB of space.  </li> <li><code>size_opt</code>: Makes cold paths optimized for size instead of optimized for speed. [Requires 'nightly' Rust]  </li> <li><code>c_exports</code> Provides C exports for the library.    </li> </ul>"},{"location":"#community-feedback","title":"Community Feedback","text":"<p>If you have questions/bug reports/etc. feel free to Open an Issue.</p> <p>Contributions are welcome and encouraged. Feel free to implement new features, make bug fixes or suggestions so long as they meet the quality standards set by the existing code in the repository.</p> <p>For an idea as to how things are set up, see Reloaded Project Configurations.</p> <p>Happy Hacking \ud83d\udc9c</p>"},{"location":"Reloaded/Readme/","title":"Readme","text":"<p>Please visit the documentation site for usage instructions &amp; more.</p>"},{"location":"Reloaded/Pages/","title":"Index","text":"The Reloaded MkDocs Theme      A Theme for MkDocs Material.          That resembles the look of Reloaded."},{"location":"Reloaded/Pages/#about","title":"About","text":"<p>This it the NexusMods theme for Material-MkDocs, inspired by the look of Reloaded-II.  </p> <p>The overall wiki theme should look fairly close to the actual launcher appearance.  </p>"},{"location":"Reloaded/Pages/#setup-from-scratch","title":"Setup From Scratch","text":"<ul> <li>Add this repository as submodule to <code>docs/Reloaded</code>.</li> <li>Save the following configuration as <code>mkdocs.yml</code> in your repository root.</li> </ul> <pre><code>site_name: Reloaded MkDocs Theme\nsite_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nrepo_name: Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\nrepo_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/Reloaded-Project\n    - icon: fontawesome/brands/twitter\n      link: https://twitter.com/thesewer56?lang=en-GB\n\nextra_css:\n  - Reloaded/Stylesheets/extra.css\n\nmarkdown_extensions:\n  - admonition\n  - tables\n  - pymdownx.details\n  - pymdownx.highlight\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_code_format\n  - pymdownx.tasklist\n  - def_list\n  - meta\n  - md_in_html\n  - attr_list\n  - footnotes\n  - pymdownx.tabbed:\n      alternate_style: true\n  - pymdownx.emoji:\n      emoji_index: !!python/name:materialx.emoji.twemoji\n      emoji_generator: !!python/name:materialx.emoji.to_svg\n\ntheme:\n  name: material\n  palette:\n    scheme: reloaded-slate\n  features:\n    - navigation.instant\n\nplugins:\n  - search\n\nnav:\n  - Home: index.md\n</code></pre> <ul> <li>Add a GitHub Actions workload in <code>.github/workflows/DeployMkDocs.yml</code>.</li> </ul> <pre><code>name: DeployMkDocs\n\n# Controls when the action will run. \non:\n  # Triggers the workflow on push on the master branch\n  push:\n    branches: [ main ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n\n      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\n      - name: Checkout Branch\n        uses: actions/checkout@v2\n        with:\n          submodules: recursive\n\n      # Deploy MkDocs\n      - name: Deploy MkDocs\n        # You may pin to the exact commit or the version.\n        # uses: mhausenblas/mkdocs-deploy-gh-pages@66340182cb2a1a63f8a3783e3e2146b7d151a0bb\n        uses: mhausenblas/mkdocs-deploy-gh-pages@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          REQUIREMENTS: ./docs/requirements.txt\n</code></pre> <ul> <li>Push to GitHub, this should produce a GitHub Pages site.  </li> <li>Go to <code>Settings -&gt; Pages</code> in your repo and select <code>gh-pages</code> branch to enable GitHub pages. </li> </ul> <p>Your page should then be live.</p> <p>Tip</p> <p>Refer to Contributing for instructions on how to locally edit and modify the wiki.</p> <p>Note</p> <p>For Reloaded3 theme use <code>reloaded3-slate</code> instead of <code>reloaded-slate</code>.</p>"},{"location":"Reloaded/Pages/#extra","title":"Extra","text":"<p>Info</p> <p>Most documentation pages will also include additional plugins; some which are used in the pages here. Here is a sample complete mkdocs.yml you can copy to your project for reference.  </p>"},{"location":"Reloaded/Pages/#technical-questions","title":"Technical Questions","text":"<p>If you have questions/bug reports/etc. feel free to Open an Issue.</p> <p>Happy Documenting \u2764\ufe0f</p>"},{"location":"Reloaded/Pages/contributing/","title":"Contributing to the Wiki: Locally","text":"<p>Info</p> <p>This page shows you how to contribute to any documentation page or wiki  based on this template.</p> <p>Note</p> <p>This theme is forked from my theme for Nexus Docs; and this page is synced with that.</p>"},{"location":"Reloaded/Pages/contributing/#tutorial","title":"Tutorial","text":"<p>Note</p> <p>If you are editing the repository with the theme itself on Windows, it might be a good idea to run <code>git config core.symlinks true</code> first to allow git to create symlinks on clone.</p> <p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I just work from inside <code>Rider</code>.  </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"Reloaded/Pages/contributing/#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the wiki locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt. <pre><code>winget install Python.Python.3\n</code></pre></p> <p>Otherwise download Python 3 from the official website or package manager.</p> </li> <li> <p>Install Material for MkDocs and Plugins (Python package)     <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\npip install mkdocs-redirects\n</code></pre></p> </li> <li> <p>Open a command prompt in the folder containing <code>mkdocs.yml</code>. and run the site locally.     <pre><code># Move to project folder.\ncd &lt;Replace this with full path to folder containing `mkdocs.yml`&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"Reloaded/Pages/license/","title":"The Reloaded Project License","text":"<p>Most components of the Reloaded are governed by the GPLv3 license.</p> <p>In some, albeit rare scenarios, certain libraries might be licensed under LGPLv3 instead.</p> <p>This is a FAQ meant to clarify the licensing choice and its implications. Please note, though, that the full license text is the final legal authority.</p>"},{"location":"Reloaded/Pages/license/#why-was-gpl-v3-chosen","title":"Why was GPL v3 chosen?","text":"<p>The primary objective is to prevent closed-source, commercial exploitation of the project.</p> <p>We want to ensure that the project isn't used within a proprietary environment for profit-making purposes such as:</p> <ul> <li>Being sold behind a Patreon paywall.</li> <li>Being integrated into a closed-source commercial product for sale.</li> </ul> <p>The Reloaded Project is a labour of love from unpaid hobbyist volunteers.</p> <p>Exploiting that work for profit feels fundamentally unfair.</p> <p>While the GPLv3 license doesn't prohibit commercial use outright, it does prevent commercial exploitation by requiring that contributions are given back to the open-source community.</p> <p>In that fashion, everyone can benefit from the projects under the Reloaded label.</p>"},{"location":"Reloaded/Pages/license/#can-i-use-reloaded-libraries-commercially","title":"Can I use Reloaded Libraries Commercially?","text":"<p>You can as long as the resulting produce is also licensed under GPLv3, and thus open source.</p>"},{"location":"Reloaded/Pages/license/#can-i-use-reloaded-libraries-in-a-closed-source-application","title":"Can I use Reloaded Libraries in a closed-source application?","text":"<p>The license terms do not permit this.</p> <p>However, if your software is completely non-commercial, meaning it's neither sold for profit, funded in development, nor hidden behind a paywall (like Patreon), we probably just look the other way.</p> <p>This often applies to non-professional programmers, learners, or those with no intent to exploit the project. We believe in understanding and leniency for those who might not know better.</p> <p>GPL v3 exists to protect the project and its contributors. If you're not exploiting the project for commercial  gain, you're not hurting us; and we will not enforce the terms of the GPL.</p> <p>If you are interested in obtaining a commercial license, or want an explicit written exemption,  please get in touch with the repository owners.</p>"},{"location":"Reloaded/Pages/license/#can-i-link-reloaded-libraries-staticallydynamically","title":"Can I link Reloaded Libraries statically/dynamically?","text":"<p>Yes, as long as you adhere to the GPLv3 license terms, you're permitted to statically link Reloaded Libraries into your project, for instance, through the use of NativeAOT or ILMerge.</p>"},{"location":"Reloaded/Pages/license/#guidelines-for-non-commercial-use","title":"Guidelines for Non-Commercial Use","text":"<p>We support and encourage the non-commercial use of Reloaded Libraries. Non-commercial use generally refers to the usage of our libraries for personal projects, educational purposes, academic research, or use by non-profit organizations.</p>"},{"location":"Reloaded/Pages/license/#personal-projects","title":"Personal Projects","text":"<p>You're free to use our libraries for projects that you undertake for your own learning, hobby or personal enjoyment. This includes creating mods for your favorite games or building your own applications for personal use.</p>"},{"location":"Reloaded/Pages/license/#educational-use","title":"Educational Use","text":"<p>Teachers and students are welcome to use our libraries as a learning resource. You can incorporate them into your teaching materials, student projects, coding bootcamps, workshops, etc.</p>"},{"location":"Reloaded/Pages/license/#academic-research","title":"Academic Research","text":"<p>Researchers may use our libraries for academic and scholarly research. We'd appreciate if you cite our work in any publications that result from research involving our libraries.</p>"},{"location":"Reloaded/Pages/license/#non-profit-organizations","title":"Non-profit Organizations","text":"<p>If you're part of a registered non-profit organization, you can use our libraries in your projects. However, any derivative work that uses our libraries must also be released under the GPL.</p> <p>Please remember, if your usage of our libraries evolves from non-commercial to commercial, you must ensure compliance with the terms of the GPL v3 license.</p>"},{"location":"Reloaded/Pages/license/#attribution-requirements","title":"Attribution Requirements","text":"<p>As Reloaded Project is a labor of love, done purely out of passion and with an aim to contribute to the broader community, we highly appreciate your support in providing attribution when using our libraries.  </p> <p>While not legally mandatory under GPL v3, it is a simple act that can go a long way in recognizing the efforts of our contributors and fostering an open and collaborative atmosphere.</p> <p>If you choose to provide attribution (and we hope you do!), here are some guidelines:</p> <ul> <li> <p>Acknowledge the Use of Reloaded Libraries: Mention that your project uses or is based on Reloaded libraries.   This could be in your project's readme, a credits page on a website, a manual, or within the software itself.</p> </li> <li> <p>Link to the Project: If possible, provide a link back to the Reloaded Project.   This allows others to explore and potentially benefit from our work.</p> </li> </ul> <p>Remember, attribution is more than just giving credit,,, it's a way of saying thank you \ud83d\udc49\ud83d\udc48, fostering reciprocal respect, and acknowledging the power of collaborative open-source development.</p> <p>We appreciate your support and look forward to seeing what amazing projects you create using Reloaded libraries!</p>"},{"location":"Reloaded/Pages/license/#code-from-mitbsd-licensed-projects","title":"Code from MIT/BSD Licensed Projects","text":"<p>In some rare instances, code from more permissively licensed projects, such as those under the <code>MIT</code> or <code>BSD</code> licenses, may be referenced, incorporated, or slightly modified within the Reloaded Project.</p> <p>It's important to us to respect the terms and intentions of these permissive licenses, which often allow their code to be used in a wide variety of contexts, including in GPL-licensed projects like ours.</p> <p>In these cases, the Reloaded Project is committed to clearly disclosing the usage of such code:</p> <ul> <li> <p>Method-Level Disclosure: For individual methods or small code snippets, we use appropriate   attribution methods, like programming language attributes. For example, methods borrowed or adapted   from MIT-licensed projects might be marked with a <code>[MITLicense]</code> attribute.</p> </li> <li> <p>File-Level Disclosure: For larger amounts of code, such as entire files or modules, we'll include   the original license text at the top of the file and clearly indicate which portions of the code originate   from a differently-licensed project.</p> </li> <li> <p>Project-Level Disclosure: If an entire library or significant portion of a project under a more permissive   license is used, we will include an acknowledgment in a prominent location, such as the readme file or the   project's license documentation.</p> </li> </ul> <p>This approach ensures we honor the contributions of the open source community at large, respect the original licenses, and maintain transparency with our users about where code originates from.</p> <p>Any files/methods or snippets marked with those attributes may be consumed using their original license terms.  </p> <p>i.e. If a method is marked with <code>[MITLicense]</code>, you may use it under the terms of the MIT license.  </p>"},{"location":"Reloaded/Pages/license/#contributing-to-the-reloaded-project","title":"Contributing to the Reloaded Project","text":"<p>We welcome and appreciate contributions to the Reloaded Project! By contributing, you agree to share your changes under the same GPLv3 license, helping to make the project better for everyone.</p>"},{"location":"Reloaded/Pages/testing-zone/","title":"Testing Zone","text":"<p>Info</p> <p>This is a dummy page with various Material MkDocs controls and features scattered throughout for testing.</p>"},{"location":"Reloaded/Pages/testing-zone/#custom-admonitions","title":"Custom Admonitions","text":"<p>Reloaded Admonition</p> <p>An admonition featuring a Reloaded logo. My source is in Stylesheets/extra.css as <code>Custom 'reloaded' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'reloaded heart' admonition</code>.</p> <p>Nexus Admonition</p> <p>An admonition featuring a Nexus logo. My source is in Stylesheets/extra.css as <code>Custom 'nexus' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'nexus heart' admonition</code>.  </p>"},{"location":"Reloaded/Pages/testing-zone/#mermaid-diagram","title":"Mermaid Diagram","text":"<p>Flowchart (Source: Nexus Archive Library):  </p> <pre><code>flowchart TD\n    subgraph Block 2\n        BigFile1.bin\n    end\n\n    subgraph Block 1\n        BigFile0.bin\n    end\n\n    subgraph Block 0\n        ModConfig.json -.-&gt; Updates.json \n        Updates.json -.-&gt; more[\"... more .json files\"]        \n    end</code></pre> <p>Sequence Diagram (Source: Reloaded3 Specification):  </p> <pre><code>sequenceDiagram\n\n    % Define Items\n    participant Mod Loader\n    participant Virtual FileSystem (VFS)\n    participant CRI CPK Archive Support\n    participant Persona 5 Royal Support\n    participant Joker Costume\n\n    % Define Actions\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Load Mod\n    Persona 5 Royal Support-&gt;&gt;Mod Loader: Request CRI CPK Archive Support API\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Receive CRI CPK Archive Support Instance\n\n    Mod Loader-&gt;&gt;Joker Costume: Load Mod\n    Mod Loader--&gt;Persona 5 Royal Support: Notification: 'Loaded Joker Costume'\n    Persona 5 Royal Support-&gt;&gt;CRI CPK Archive Support: Add Files from 'Joker Costume' to CPK Archive (via API)</code></pre> <p>State Diagram (Source: Mermaid Docs):  </p> <pre><code>stateDiagram-v2\n    [*] --&gt; Still\n    Still --&gt; [*]\n\n    Still --&gt; Moving\n    Moving --&gt; Still\n    Moving --&gt; Crash\n    Crash --&gt; [*]</code></pre> <p>Class Diagram (Arbitrary)</p> <pre><code>classDiagram\n    class Animal\n    `NexusMobile\u2122` &lt;|-- Car</code></pre> <p>Note</p> <p>At time of writing, version of Mermaid is a bit outdated here; and other diagrams might not render correctly (even on unmodified theme); thus certain diagrams have been omitted from here.</p>"},{"location":"Reloaded/Pages/testing-zone/#code-block","title":"Code Block","text":"<p>Snippet from C# version of Sewer's Virtual FileSystem (VFS):</p> <pre><code>/// &lt;summary&gt;\n/// Tries to get files for a specific folder, assuming the input path is already in upper case.\n/// &lt;/summary&gt;\n/// &lt;param name=\"folderPath\"&gt;The folder to find. Already lowercase.&lt;/param&gt;\n/// &lt;param name=\"value\"&gt;The returned folder instance.&lt;/param&gt;\n/// &lt;returns&gt;True if found, else false.&lt;/returns&gt;\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\npublic bool TryGetFolderUpper(ReadOnlySpan&lt;char&gt; folderPath, out SpanOfCharDict&lt;TTarget&gt; value)\n{\n    // Must be O(1)\n    value = default!;        \n\n    // Compare equality.\n    // Note to devs: Do not invert branches, we optimise for hot paths here.\n    if (folderPath.StartsWith(Prefix))\n    {\n        // Check for subfolder in branchless way.\n        // In CLR, bool is length 1, so conversion to byte should be safe.\n        // Even suppose it is not; as long as code is little endian; truncating int/4 bytes to byte still results \n        // in correct answer.\n        var hasSubfolder = Prefix.Length != folderPath.Length;\n        var hasSubfolderByte = Unsafe.As&lt;bool, byte&gt;(ref hasSubfolder);\n        var nextFolder = folderPath.SliceFast(Prefix.Length + hasSubfolderByte);\n\n        return SubfolderToFiles.TryGetValue(nextFolder, out value!);\n    }\n\n    return false;\n}\n</code></pre> <p>Something more number heavy, Fast Inverse Square Root from Quake III Arena (unmodified). <pre><code>float Q_rsqrt( float number )\n{\n    long i;\n    float x2, y;\n    const float threehalfs = 1.5F;\n\n    x2 = number * 0.5F;\n    y  = number;\n    i  = * ( long * ) &amp;y;                       // evil floating point bit level hacking\n    i  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck? \n    y  = * ( float * ) &amp;i;\n    y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration\n//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed\n\n    return y;\n}\n</code></pre></p>"},{"location":"Reloaded/Pages/testing-zone/#default-admonitions","title":"Default Admonitions","text":"<p>Note</p> <p>Test</p> <p>Abstract</p> <p>Test</p> <p>Info</p> <p>Test</p> <p>Tip</p> <p>Test</p> <p>Success</p> <p>Test</p> <p>Question</p> <p>Test</p> <p>Warning</p> <p>Test</p> <p>Failure</p> <p>Test</p> <p>Danger</p> <p>Test</p> <p>Bug</p> <p>Test</p> <p>Example</p> <p>Test</p> <p>Quote</p> <p>Test</p>"},{"location":"Reloaded/Pages/testing-zone/#tables","title":"Tables","text":"Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource"},{"location":"Reloaded/docs/Pages/","title":"Index","text":"The Reloaded MkDocs Theme      A Theme for MkDocs Material.          That resembles the look of Reloaded."},{"location":"Reloaded/docs/Pages/#about","title":"About","text":"<p>This it the NexusMods theme for Material-MkDocs, inspired by the look of Reloaded-II.  </p> <p>The overall wiki theme should look fairly close to the actual launcher appearance.  </p>"},{"location":"Reloaded/docs/Pages/#setup-from-scratch","title":"Setup From Scratch","text":"<ul> <li>Add this repository as submodule to <code>docs/Reloaded</code>.</li> <li>Save the following configuration as <code>mkdocs.yml</code> in your repository root.</li> </ul> <pre><code>site_name: Reloaded MkDocs Theme\nsite_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nrepo_name: Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\nrepo_url: https://github.com/Reloaded-Project/Reloaded.MkDocsMaterial.Themes.R2\n\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/Reloaded-Project\n    - icon: fontawesome/brands/twitter\n      link: https://twitter.com/thesewer56?lang=en-GB\n\nextra_css:\n  - Reloaded/Stylesheets/extra.css\n\nmarkdown_extensions:\n  - admonition\n  - tables\n  - pymdownx.details\n  - pymdownx.highlight\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_code_format\n  - pymdownx.tasklist\n  - def_list\n  - meta\n  - md_in_html\n  - attr_list\n  - footnotes\n  - pymdownx.tabbed:\n      alternate_style: true\n  - pymdownx.emoji:\n      emoji_index: !!python/name:materialx.emoji.twemoji\n      emoji_generator: !!python/name:materialx.emoji.to_svg\n\ntheme:\n  name: material\n  palette:\n    scheme: reloaded-slate\n  features:\n    - navigation.instant\n\nplugins:\n  - search\n\nnav:\n  - Home: index.md\n</code></pre> <ul> <li>Add a GitHub Actions workload in <code>.github/workflows/DeployMkDocs.yml</code>.</li> </ul> <pre><code>name: DeployMkDocs\n\n# Controls when the action will run. \non:\n  # Triggers the workflow on push on the master branch\n  push:\n    branches: [ main ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n\n      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\n      - name: Checkout Branch\n        uses: actions/checkout@v2\n        with:\n          submodules: recursive\n\n      # Deploy MkDocs\n      - name: Deploy MkDocs\n        # You may pin to the exact commit or the version.\n        # uses: mhausenblas/mkdocs-deploy-gh-pages@66340182cb2a1a63f8a3783e3e2146b7d151a0bb\n        uses: mhausenblas/mkdocs-deploy-gh-pages@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          REQUIREMENTS: ./docs/requirements.txt\n</code></pre> <ul> <li>Push to GitHub, this should produce a GitHub Pages site.  </li> <li>Go to <code>Settings -&gt; Pages</code> in your repo and select <code>gh-pages</code> branch to enable GitHub pages. </li> </ul> <p>Your page should then be live.</p> <p>Tip</p> <p>Refer to Contributing for instructions on how to locally edit and modify the wiki.</p> <p>Note</p> <p>For Reloaded3 theme use <code>reloaded3-slate</code> instead of <code>reloaded-slate</code>.</p>"},{"location":"Reloaded/docs/Pages/#extra","title":"Extra","text":"<p>Info</p> <p>Most documentation pages will also include additional plugins; some which are used in the pages here. Here is a sample complete mkdocs.yml you can copy to your project for reference.  </p>"},{"location":"Reloaded/docs/Pages/#technical-questions","title":"Technical Questions","text":"<p>If you have questions/bug reports/etc. feel free to Open an Issue.</p> <p>Happy Documenting \u2764\ufe0f</p>"},{"location":"Reloaded/docs/Pages/contributing/","title":"Contributing to the Wiki: Locally","text":"<p>Info</p> <p>This page shows you how to contribute to any documentation page or wiki  based on this template.</p> <p>Note</p> <p>This theme is forked from my theme for Nexus Docs; and this page is synced with that.</p>"},{"location":"Reloaded/docs/Pages/contributing/#tutorial","title":"Tutorial","text":"<p>Note</p> <p>If you are editing the repository with the theme itself on Windows, it might be a good idea to run <code>git config core.symlinks true</code> first to allow git to create symlinks on clone.</p> <p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I just work from inside <code>Rider</code>.  </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"Reloaded/docs/Pages/contributing/#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the wiki locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt. <pre><code>winget install Python.Python.3\n</code></pre></p> <p>Otherwise download Python 3 from the official website or package manager.</p> </li> <li> <p>Install Material for MkDocs and Plugins (Python package)     <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\npip install mkdocs-redirects\n</code></pre></p> </li> <li> <p>Open a command prompt in the folder containing <code>mkdocs.yml</code>. and run the site locally.     <pre><code># Move to project folder.\ncd &lt;Replace this with full path to folder containing `mkdocs.yml`&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"Reloaded/docs/Pages/license/","title":"The Reloaded Project License","text":"<p>Most components of the Reloaded are governed by the GPLv3 license.</p> <p>In some, albeit rare scenarios, certain libraries might be licensed under LGPLv3 instead.</p> <p>This is a FAQ meant to clarify the licensing choice and its implications. Please note, though, that the full license text is the final legal authority.</p>"},{"location":"Reloaded/docs/Pages/license/#why-was-gpl-v3-chosen","title":"Why was GPL v3 chosen?","text":"<p>The primary objective is to prevent closed-source, commercial exploitation of the project.</p> <p>We want to ensure that the project isn't used within a proprietary environment for profit-making purposes such as:</p> <ul> <li>Being sold behind a Patreon paywall.</li> <li>Being integrated into a closed-source commercial product for sale.</li> </ul> <p>The Reloaded Project is a labour of love from unpaid hobbyist volunteers.</p> <p>Exploiting that work for profit feels fundamentally unfair.</p> <p>While the GPLv3 license doesn't prohibit commercial use outright, it does prevent commercial exploitation by requiring that contributions are given back to the open-source community.</p> <p>In that fashion, everyone can benefit from the projects under the Reloaded label.</p>"},{"location":"Reloaded/docs/Pages/license/#can-i-use-reloaded-libraries-commercially","title":"Can I use Reloaded Libraries Commercially?","text":"<p>You can as long as the resulting produce is also licensed under GPLv3, and thus open source.</p>"},{"location":"Reloaded/docs/Pages/license/#can-i-use-reloaded-libraries-in-a-closed-source-application","title":"Can I use Reloaded Libraries in a closed-source application?","text":"<p>The license terms do not permit this.</p> <p>However, if your software is completely non-commercial, meaning it's neither sold for profit, funded in development, nor hidden behind a paywall (like Patreon), we probably just look the other way.</p> <p>This often applies to non-professional programmers, learners, or those with no intent to exploit the project. We believe in understanding and leniency for those who might not know better.</p> <p>GPL v3 exists to protect the project and its contributors. If you're not exploiting the project for commercial  gain, you're not hurting us; and we will not enforce the terms of the GPL.</p> <p>If you are interested in obtaining a commercial license, or want an explicit written exemption,  please get in touch with the repository owners.</p>"},{"location":"Reloaded/docs/Pages/license/#can-i-link-reloaded-libraries-staticallydynamically","title":"Can I link Reloaded Libraries statically/dynamically?","text":"<p>Yes, as long as you adhere to the GPLv3 license terms, you're permitted to statically link Reloaded Libraries into your project, for instance, through the use of NativeAOT or ILMerge.</p>"},{"location":"Reloaded/docs/Pages/license/#guidelines-for-non-commercial-use","title":"Guidelines for Non-Commercial Use","text":"<p>We support and encourage the non-commercial use of Reloaded Libraries. Non-commercial use generally refers to the usage of our libraries for personal projects, educational purposes, academic research, or use by non-profit organizations.</p>"},{"location":"Reloaded/docs/Pages/license/#personal-projects","title":"Personal Projects","text":"<p>You're free to use our libraries for projects that you undertake for your own learning, hobby or personal enjoyment. This includes creating mods for your favorite games or building your own applications for personal use.</p>"},{"location":"Reloaded/docs/Pages/license/#educational-use","title":"Educational Use","text":"<p>Teachers and students are welcome to use our libraries as a learning resource. You can incorporate them into your teaching materials, student projects, coding bootcamps, workshops, etc.</p>"},{"location":"Reloaded/docs/Pages/license/#academic-research","title":"Academic Research","text":"<p>Researchers may use our libraries for academic and scholarly research. We'd appreciate if you cite our work in any publications that result from research involving our libraries.</p>"},{"location":"Reloaded/docs/Pages/license/#non-profit-organizations","title":"Non-profit Organizations","text":"<p>If you're part of a registered non-profit organization, you can use our libraries in your projects. However, any derivative work that uses our libraries must also be released under the GPL.</p> <p>Please remember, if your usage of our libraries evolves from non-commercial to commercial, you must ensure compliance with the terms of the GPL v3 license.</p>"},{"location":"Reloaded/docs/Pages/license/#attribution-requirements","title":"Attribution Requirements","text":"<p>As Reloaded Project is a labor of love, done purely out of passion and with an aim to contribute to the broader community, we highly appreciate your support in providing attribution when using our libraries.  </p> <p>While not legally mandatory under GPL v3, it is a simple act that can go a long way in recognizing the efforts of our contributors and fostering an open and collaborative atmosphere.</p> <p>If you choose to provide attribution (and we hope you do!), here are some guidelines:</p> <ul> <li> <p>Acknowledge the Use of Reloaded Libraries: Mention that your project uses or is based on Reloaded libraries.   This could be in your project's readme, a credits page on a website, a manual, or within the software itself.</p> </li> <li> <p>Link to the Project: If possible, provide a link back to the Reloaded Project.   This allows others to explore and potentially benefit from our work.</p> </li> </ul> <p>Remember, attribution is more than just giving credit,,, it's a way of saying thank you \ud83d\udc49\ud83d\udc48, fostering reciprocal respect, and acknowledging the power of collaborative open-source development.</p> <p>We appreciate your support and look forward to seeing what amazing projects you create using Reloaded libraries!</p>"},{"location":"Reloaded/docs/Pages/license/#code-from-mitbsd-licensed-projects","title":"Code from MIT/BSD Licensed Projects","text":"<p>In some rare instances, code from more permissively licensed projects, such as those under the <code>MIT</code> or <code>BSD</code> licenses, may be referenced, incorporated, or slightly modified within the Reloaded Project.</p> <p>It's important to us to respect the terms and intentions of these permissive licenses, which often allow their code to be used in a wide variety of contexts, including in GPL-licensed projects like ours.</p> <p>In these cases, the Reloaded Project is committed to clearly disclosing the usage of such code:</p> <ul> <li> <p>Method-Level Disclosure: For individual methods or small code snippets, we use appropriate   attribution methods, like programming language attributes. For example, methods borrowed or adapted   from MIT-licensed projects might be marked with a <code>[MITLicense]</code> attribute.</p> </li> <li> <p>File-Level Disclosure: For larger amounts of code, such as entire files or modules, we'll include   the original license text at the top of the file and clearly indicate which portions of the code originate   from a differently-licensed project.</p> </li> <li> <p>Project-Level Disclosure: If an entire library or significant portion of a project under a more permissive   license is used, we will include an acknowledgment in a prominent location, such as the readme file or the   project's license documentation.</p> </li> </ul> <p>This approach ensures we honor the contributions of the open source community at large, respect the original licenses, and maintain transparency with our users about where code originates from.</p> <p>Any files/methods or snippets marked with those attributes may be consumed using their original license terms.  </p> <p>i.e. If a method is marked with <code>[MITLicense]</code>, you may use it under the terms of the MIT license.  </p>"},{"location":"Reloaded/docs/Pages/license/#contributing-to-the-reloaded-project","title":"Contributing to the Reloaded Project","text":"<p>We welcome and appreciate contributions to the Reloaded Project! By contributing, you agree to share your changes under the same GPLv3 license, helping to make the project better for everyone.</p>"},{"location":"Reloaded/docs/Pages/testing-zone/","title":"Testing Zone","text":"<p>Info</p> <p>This is a dummy page with various Material MkDocs controls and features scattered throughout for testing.</p>"},{"location":"Reloaded/docs/Pages/testing-zone/#custom-admonitions","title":"Custom Admonitions","text":"<p>Reloaded Admonition</p> <p>An admonition featuring a Reloaded logo. My source is in Stylesheets/extra.css as <code>Custom 'reloaded' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'reloaded heart' admonition</code>.</p> <p>Nexus Admonition</p> <p>An admonition featuring a Nexus logo. My source is in Stylesheets/extra.css as <code>Custom 'nexus' admonition</code>.  </p> <p>Heart Admonition</p> <p>An admonition featuring a heart; because we want to contribute back to the open source community. My source is in Stylesheets/extra.css as <code>Custom 'nexus heart' admonition</code>.  </p>"},{"location":"Reloaded/docs/Pages/testing-zone/#mermaid-diagram","title":"Mermaid Diagram","text":"<p>Flowchart (Source: Nexus Archive Library):  </p> <pre><code>flowchart TD\n    subgraph Block 2\n        BigFile1.bin\n    end\n\n    subgraph Block 1\n        BigFile0.bin\n    end\n\n    subgraph Block 0\n        ModConfig.json -.-&gt; Updates.json \n        Updates.json -.-&gt; more[\"... more .json files\"]        \n    end</code></pre> <p>Sequence Diagram (Source: Reloaded3 Specification):  </p> <pre><code>sequenceDiagram\n\n    % Define Items\n    participant Mod Loader\n    participant Virtual FileSystem (VFS)\n    participant CRI CPK Archive Support\n    participant Persona 5 Royal Support\n    participant Joker Costume\n\n    % Define Actions\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Load Mod\n    Persona 5 Royal Support-&gt;&gt;Mod Loader: Request CRI CPK Archive Support API\n    Mod Loader-&gt;&gt;Persona 5 Royal Support: Receive CRI CPK Archive Support Instance\n\n    Mod Loader-&gt;&gt;Joker Costume: Load Mod\n    Mod Loader--&gt;Persona 5 Royal Support: Notification: 'Loaded Joker Costume'\n    Persona 5 Royal Support-&gt;&gt;CRI CPK Archive Support: Add Files from 'Joker Costume' to CPK Archive (via API)</code></pre> <p>State Diagram (Source: Mermaid Docs):  </p> <pre><code>stateDiagram-v2\n    [*] --&gt; Still\n    Still --&gt; [*]\n\n    Still --&gt; Moving\n    Moving --&gt; Still\n    Moving --&gt; Crash\n    Crash --&gt; [*]</code></pre> <p>Class Diagram (Arbitrary)</p> <pre><code>classDiagram\n    class Animal\n    `NexusMobile\u2122` &lt;|-- Car</code></pre> <p>Note</p> <p>At time of writing, version of Mermaid is a bit outdated here; and other diagrams might not render correctly (even on unmodified theme); thus certain diagrams have been omitted from here.</p>"},{"location":"Reloaded/docs/Pages/testing-zone/#code-block","title":"Code Block","text":"<p>Snippet from C# version of Sewer's Virtual FileSystem (VFS):</p> <pre><code>/// &lt;summary&gt;\n/// Tries to get files for a specific folder, assuming the input path is already in upper case.\n/// &lt;/summary&gt;\n/// &lt;param name=\"folderPath\"&gt;The folder to find. Already lowercase.&lt;/param&gt;\n/// &lt;param name=\"value\"&gt;The returned folder instance.&lt;/param&gt;\n/// &lt;returns&gt;True if found, else false.&lt;/returns&gt;\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\npublic bool TryGetFolderUpper(ReadOnlySpan&lt;char&gt; folderPath, out SpanOfCharDict&lt;TTarget&gt; value)\n{\n    // Must be O(1)\n    value = default!;        \n\n    // Compare equality.\n    // Note to devs: Do not invert branches, we optimise for hot paths here.\n    if (folderPath.StartsWith(Prefix))\n    {\n        // Check for subfolder in branchless way.\n        // In CLR, bool is length 1, so conversion to byte should be safe.\n        // Even suppose it is not; as long as code is little endian; truncating int/4 bytes to byte still results \n        // in correct answer.\n        var hasSubfolder = Prefix.Length != folderPath.Length;\n        var hasSubfolderByte = Unsafe.As&lt;bool, byte&gt;(ref hasSubfolder);\n        var nextFolder = folderPath.SliceFast(Prefix.Length + hasSubfolderByte);\n\n        return SubfolderToFiles.TryGetValue(nextFolder, out value!);\n    }\n\n    return false;\n}\n</code></pre> <p>Something more number heavy, Fast Inverse Square Root from Quake III Arena (unmodified). <pre><code>float Q_rsqrt( float number )\n{\n    long i;\n    float x2, y;\n    const float threehalfs = 1.5F;\n\n    x2 = number * 0.5F;\n    y  = number;\n    i  = * ( long * ) &amp;y;                       // evil floating point bit level hacking\n    i  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck? \n    y  = * ( float * ) &amp;i;\n    y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration\n//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed\n\n    return y;\n}\n</code></pre></p>"},{"location":"Reloaded/docs/Pages/testing-zone/#default-admonitions","title":"Default Admonitions","text":"<p>Note</p> <p>Test</p> <p>Abstract</p> <p>Test</p> <p>Info</p> <p>Test</p> <p>Tip</p> <p>Test</p> <p>Success</p> <p>Test</p> <p>Question</p> <p>Test</p> <p>Warning</p> <p>Test</p> <p>Failure</p> <p>Test</p> <p>Danger</p> <p>Test</p> <p>Bug</p> <p>Test</p> <p>Example</p> <p>Test</p> <p>Quote</p> <p>Test</p>"},{"location":"Reloaded/docs/Pages/testing-zone/#tables","title":"Tables","text":"Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource"},{"location":"specification/allocation-algorithm/","title":"Allocation Algorithm","text":"<p>Allocating within certain proximity on different platforms can be tricky.</p> <p>This page provides snippets from the source to give guidance for other language ports, or for those implementing similar solutions.</p> <p>For a full implementation, look at this repo's code.</p> <p>Allocating buffers and locators generally follows the same algorithm; with minor platform specific differences.</p> <ul> <li>Enumerate Free Memory Pages</li> <li>Allocating A Buffer<ul> <li>Check if Page Satisfies Constraints </li> </ul> </li> </ul>"},{"location":"specification/allocation-algorithm/#finding-free-memory-pages","title":"Finding Free Memory Pages","text":"<p>In order to find all free memory regions we do a page walk using VirtualQuery(Ex).</p>"},{"location":"specification/allocation-algorithm/#windows","title":"Windows","text":"C#C++ <pre><code>private static unsafe LocatorItem Allocate&lt;T&gt;(T k32, nuint maxAddress, BufferAllocatorSettings settings) where T : IKernel32\n{\n    // Note: `k32.VirtualQuery` is `VirtualQueryEx` if targeting another process.\n    // Until we get all of the pages.\n    nuint currentAddress = settings.MinAddress;\n    while (currentAddress &lt;= maxAddress)\n    {\n        // Get our info from VirtualQueryEx.\n        var memoryInformation = new MEMORY_BASIC_INFORMATION();\n        var hasPage = k32.VirtualQuery(currentAddress, &amp;memoryInformation);\n        if (hasPage == 0)\n            break;\n\n        // Add the page and increment address iterator to go to next page.\n        if (TryAllocateBuffer(k32, ref memoryInformation, settings, out var item))\n            return item;\n\n        currentAddress += memoryInformation.RegionSize;\n    }\n\n    // Some form of error handling.\n    throw new MemoryBufferAllocationException(settings.MinAddress, settings.MaxAddress, (int)settings.Size);\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n#include &lt;windows.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;memory&gt;\n\nLocatorItem Allocate(BufferAllocatorSettings settings, uintptr_t maxAddress)\n{\n    // Note: `VirtualQuery` is `VirtualQueryEx` if targeting another process. Abstract this if needed.\n    // Until we get all of the pages.\n    uintptr_t currentAddress = settings.MinAddress;\n    while (currentAddress &lt;= maxAddress)\n    {\n        // Get our info from VirtualQueryEx.\n        MEMORY_BASIC_INFORMATION memoryInformation;\n        DWORD hasPage = VirtualQuery((LPVOID)currentAddress, &amp;memoryInformation, sizeof(memoryInformation));\n        if (hasPage == 0)\n            break;\n\n        // Add the page and increment address iterator to go to next page.\n        LocatorItem item;\n        if (TryAllocateBuffer(memoryInformation, settings, item))\n            return item;\n\n        currentAddress += memoryInformation.RegionSize;\n    }\n\n    // Some form of error handling.\n    throw std::runtime_error(\"Failed to allocate memory buffer\");\n}\n</code></pre>"},{"location":"specification/allocation-algorithm/#linux","title":"Linux","text":"<p>In order to find all free memory regions we need to parse a text file at <code>$\"/proc/{processId}/maps\"</code>.</p> <p>The following code parses an individual line of said file:  </p> C#C++ <pre><code>internal static MemoryMapEntry ParseMemoryMapEntry(string line)\n{\n    // Example line: \"7f9c89991000-7f9c89993000 r--p 00000000 08:01 3932177                    /path/to/file\"\n    ReadOnlySpan&lt;char&gt; lineSpan = line.AsSpan();\n    var dashIndex = lineSpan.IndexOf('-');\n    if (dashIndex == -1)\n        ThrowHelpers.ThrowLinuxBadMemoryMapEntry();\n\n    var spaceIndex = lineSpan.Slice(dashIndex).IndexOf(' ');\n    if (spaceIndex == -1)\n        ThrowHelpers.ThrowLinuxBadMemoryMapEntry();\n\n    ReadOnlySpan&lt;char&gt; startAddressSpan = lineSpan.SliceFast(..dashIndex);\n    ReadOnlySpan&lt;char&gt; endAddressSpan = lineSpan.SliceFast(dashIndex + 1, spaceIndex - 1);\n\n    return new MemoryMapEntry\n    {\n        StartAddress = ParseHexAddress(startAddressSpan),\n        EndAddress = ParseHexAddress(endAddressSpan)\n    };\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;cstddef&gt;\n\nstruct MemoryMapEntry {\n    unsigned long StartAddress;\n    unsigned long EndAddress;\n};\n\nMemoryMapEntry ParseMemoryMapEntry(const std::string&amp; line) {\n    // Example line: \"7f9c89991000-7f9c89993000 r--p 00000000 08:01 3932177                    /path/to/file\"\n    std::size_t dashIndex = line.find('-');\n    if (dashIndex == std::string::npos) {\n        throw std::runtime_error(\"Bad Memory Map Entry\");\n    }\n\n    std::size_t spaceIndex = line.find(' ', dashIndex);\n    if (spaceIndex == std::string::npos) {\n        throw std::runtime_error(\"Bad Memory Map Entry\");\n    }\n\n    std::string startAddressStr = line.substr(0, dashIndex);\n    std::string endAddressStr = line.substr(dashIndex + 1, spaceIndex - dashIndex - 1);\n\n    MemoryMapEntry entry;\n    entry.StartAddress = std::stoul(startAddressStr, nullptr, 16);\n    entry.EndAddress = std::stoul(endAddressStr, nullptr, 16);\n\n    return entry;\n}\n</code></pre> <p>Parsing this file gives you all of the mapped memory regions. Any regions not listed in this files are considered free, thus, we should try allocating there. We can extract the free regions in the following fashion:  </p> C#C++ <pre><code>/// &lt;summary&gt;\n/// Returns all free regions based on the found regions.\n/// &lt;/summary&gt;\n/// &lt;param name=\"regions\"&gt;The found regions.&lt;/param&gt;\npublic static List&lt;MemoryMapEntry&gt; GetFreeRegions(Span&lt;MemoryMapEntry&gt; regions)\n{\n    nuint lastEndAddress = 0;\n    var freeRegions = new List&lt;MemoryMapEntry&gt;(regions.Length + 2); // +2 for start and finish\n\n    for (int x = 0; x &lt; regions.Length; x++)\n    {\n        MemoryMapEntry entry = regions.DangerousGetReferenceAt(x);\n        if (entry.StartAddress &gt; lastEndAddress)\n        {\n            freeRegions.Add(new MemoryMapEntry\n            {\n                StartAddress = lastEndAddress,\n                EndAddress = entry.StartAddress - 1\n            });\n        }\n\n        lastEndAddress = entry.EndAddress + 1;\n    }\n\n    // After the last region, up to the end of memory\n    if (lastEndAddress &lt;= Cached.GetMaxAddress())\n    {\n        freeRegions.Add(new MemoryMapEntry\n        {\n            StartAddress = lastEndAddress,\n            EndAddress = Cached.GetMaxAddress()\n        });\n    }\n\n    return freeRegions;\n}\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;climits&gt;\n#include &lt;stdexcept&gt;\n#include &lt;cstdint&gt;\n#ifdef _WIN32\n#include &lt;Windows.h&gt;\n#else\n#include &lt;unistd.h&gt;\n#endif\n\nclass Cached\n{\nprivate:\n    static constexpr int ScPagesizeLinux = 30;\n    static constexpr int ScPagesizeOsx = 29;\n\n    static uint64_t s_maxAddress;\n    static int s_allocationGranularity;\n\npublic:\n    static uint64_t GetMaxAddress() { return s_maxAddress; }\n    static int GetAllocationGranularity() { return s_allocationGranularity; }\n\n    static void Initialize()\n    {\n#ifdef _WIN32\n        SYSTEM_INFO info;\n        GetSystemInfo(&amp;info);\n        s_maxAddress = reinterpret_cast&lt;uint64_t&gt;(info.lpMaximumApplicationAddress);\n        s_allocationGranularity = static_cast&lt;int&gt;(info.dwAllocationGranularity);\n#elif __linux__\n        s_maxAddress = UINTPTR_MAX;\n        s_allocationGranularity = static_cast&lt;int&gt;(sysconf(ScPagesizeLinux));\n#elif __APPLE__\n        s_maxAddress = UINTPTR_MAX;\n        s_allocationGranularity = static_cast&lt;int&gt;(sysconf(ScPagesizeOsx));\n#else\n        throw std::runtime_error(\"Platform not supported\");\n#endif\n    }\n};\n\n// Initialize static members\nuint64_t Cached::s_maxAddress = 0;\nint Cached::s_allocationGranularity = 0;\n\nstd::vector&lt;MemoryMapEntry&gt; GetFreeRegions(std::vector&lt;MemoryMapEntry&gt; regions)\n{\n    uintptr_t lastEndAddress = 0;\n    std::vector&lt;MemoryMapEntry&gt; freeRegions;\n    freeRegions.reserve(regions.size() + 2); // +2 for start and finish\n\n    for (auto&amp; entry : regions)\n    {\n        if (entry.StartAddress &gt; lastEndAddress)\n        {\n            freeRegions.push_back({lastEndAddress, entry.StartAddress - 1});\n        }\n\n        lastEndAddress = entry.EndAddress + 1;\n    }\n\n    // After the last region, up to the end of memory\n    if (lastEndAddress &lt;= Cached::GetMaxAddress())\n    {\n        freeRegions.push_back({lastEndAddress, Cached::GetMaxAddress()});\n    }\n\n    return freeRegions;\n}\n</code></pre> <p>Lastly, try allocating based on the free regions, like this:  </p> C#C++ <pre><code>// Until we get all of the pages.\nforeach (MemoryMapEntry region in LinuxMapParser.GetFreeRegions(settings.TargetProcess))\n{\n    // Exit if we are done iterating.\n    if (region.StartAddress &gt; settings.MaxAddress)\n        break;\n\n    // Add the page and increment address iterator to go to next page.\n    if (TryAllocateBuffer(region, settings, out var item))\n        return item;\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n// Note: Uses C++20\n#include &lt;sys/mman.h&gt;\n#include &lt;array&gt;\n\n// Until we get all of the pages.\nfor (const MemoryMapEntry&amp; region : LinuxMapParser::GetFreeRegions(settings.TargetProcess))\n{\n    // Exit if we are done iterating.\n    if (region.StartAddress &gt; settings.MaxAddress)\n        break;\n\n    // Add the page and increment address iterator to go to next page.\n    LocatorItem item;\n    if (TryAllocateBuffer(region, settings, item))\n        return item;\n}\n</code></pre>"},{"location":"specification/allocation-algorithm/#osx","title":"OSX","text":"<p>For OSX, you have to find all used pages via <code>mach_vm_region</code>, then use that information to find the free pages.</p> <p>It seems OSX seems to impose a minimum address, in around where the <code>.text</code> segment would eventually get allocated. Usually getting memory in first 2GiB appears impossible.</p> C#C++ <pre><code>private static List&lt;(nuint addr, nuint size)&gt; GetFreePages(nuint minAddress, nuint maxAddress, nuint selfTask)\n{\n    var result = new List&lt;(nuint addr, nuint size)&gt;();\n    uint infoCount = VM_REGION_BASIC_INFO_COUNT;\n    var currentAddress = minAddress;\n\n    // Until we get all of the pages.\n    while (currentAddress &lt;= maxAddress)\n    {\n        var actualAddress = currentAddress;\n        nuint availableSize = 0;\n        int kr = mach_vm_region(selfTask, ref actualAddress, ref availableSize, VM_REGION_BASIC_INFO_64, out vm_region_basic_info_64 _, ref infoCount, out _);\n\n        // KERN_INVALID_ADDRESS, i.e. no more regions.\n        if (kr == 1)\n        {\n            var padding = maxAddress - currentAddress;\n            if (padding &gt; 0)\n                result.Add((currentAddress, padding));\n\n            break;\n        }\n\n        // Any other error.\n        if (kr != 0)\n            break;\n\n        var freeBytes = actualAddress - currentAddress;\n        if (freeBytes &gt; 0)\n            result.Add((currentAddress, freeBytes));\n\n        currentAddress = actualAddress + availableSize;\n    }\n\n    return result;\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n// I also cannot guarantee this one compiles, I don't have a macOS compiler readily available.\n#include &lt;vector&gt;\n#include &lt;mach/mach.h&gt;\n\nstruct PageRange {\n    mach_vm_address_t addr;\n    mach_vm_size_t size;\n};\n\nstd::vector&lt;PageRange&gt; GetFreePages(mach_vm_address_t minAddress, mach_vm_address_t maxAddress, mach_port_t selfTask) {\n    std::vector&lt;PageRange&gt; result;\n    mach_msg_type_number_t infoCount = VM_REGION_BASIC_INFO_COUNT_64;\n    mach_vm_address_t currentAddress = minAddress;\n\n    // Until we get all of the pages.\n    while (currentAddress &lt;= maxAddress) {\n        mach_vm_address_t actualAddress = currentAddress;\n        mach_vm_size_t availableSize = 0;\n        vm_region_basic_info_data_64_t info;\n        mach_msg_type_number_t infoCnt = VM_REGION_BASIC_INFO_COUNT_64;\n        mach_port_t object_name;\n        kern_return_t kr = mach_vm_region(selfTask, &amp;actualAddress, &amp;availableSize, VM_REGION_BASIC_INFO, reinterpret_cast&lt;vm_region_info_t&gt;(&amp;info), &amp;infoCnt, &amp;object_name);\n\n        // KERN_INVALID_ADDRESS, i.e. no more regions.\n        if (kr == KERN_INVALID_ADDRESS) {\n            mach_vm_size_t padding = maxAddress - currentAddress;\n            if (padding &gt; 0)\n                result.push_back({currentAddress, padding});\n\n            break;\n        }\n\n        // Any other error.\n        if (kr != KERN_SUCCESS)\n            break;\n\n        mach_vm_size_t freeBytes = actualAddress - currentAddress;\n        if (freeBytes &gt; 0)\n            result.push_back({currentAddress, freeBytes});\n\n        currentAddress = actualAddress + availableSize;\n    }\n\n    return result;\n}\n</code></pre> <p>Now, try allocating in those free pages:  </p> C#C++ <pre><code>// Until we get all of the pages.\nforeach (var page in GetFreePages(currentAddress, (nuint)maxAddress, selfTask))\n{\n    if (TryAllocateBuffer(page.addr, page.size, settings, selfTask, out var item))\n        return item;\n}\n</code></pre> <pre><code>// results is replaced with a vector because stack allocated arrays are not commonly used in C++\nstd::vector&lt;mach_vm_address_t&gt; results(4);\nfor(auto addr : GetBufferPointersInPageRange(pageAddress, pageSize, static_cast&lt;int&gt;(settings.size), settings.minAddress, settings.maxAddress, results))\n{\n    kern_return_t kr = mach_vm_allocate(selfTask, &amp;addr, settings.size, 0);\n\n    if (kr != KERN_SUCCESS)\n        continue;\n\n    result = {addr, settings.size};\n    return true;\n}\n</code></pre> <p>It appears you can't use <code>mmap</code> for allocating on OSX in these scenarios, so make sure to use <code>mach_vm_allocate</code>.</p>"},{"location":"specification/allocation-algorithm/#allocating-a-buffer","title":"Allocating a Buffer","text":""},{"location":"specification/allocation-algorithm/#windows_1","title":"Windows","text":"<p>For all found pages, satisfying constraints, we then do VirtualAlloc(Ex) to reserve and commit them.</p> C#C++ <pre><code>private static bool TryAllocateBuffer&lt;T&gt;(T k32, ref MEMORY_BASIC_INFORMATION pageInfo, BufferAllocatorSettings settings, out LocatorItem result) where T : IKernel32\n{\n    result = default;\n    // Fast return if page is not free.\n    if (pageInfo.State != MEM_STATE.FREE)\n        return false;\n\n    Span&lt;nuint&gt; results = stackalloc nuint[4];\n    foreach (var addr in GetBufferPointersInPageRange(ref pageInfo, (int)settings.Size, settings.MinAddress, settings.MaxAddress, results))\n    {\n        nuint allocated = k32.VirtualAlloc(addr, (nuint)settings.Size);\n        if (allocated == 0)\n            continue;\n\n        // Sanity test in case of '0' value input and random address allocated.\n        if (allocated != addr)\n        {\n            k32.VirtualFree(allocated, 0);\n            continue;\n        }\n\n        result = new LocatorItem(allocated, settings.Size);\n        return true;\n    }\n\n    return false;\n}\n\n/// &lt;summary&gt;\n/// Checks if memory can be allocated inside &lt;paramref name=\"pageInfo\"/&gt; provided the size, minimum and maximum pointer.\n/// &lt;/summary&gt;\n/// &lt;param name=\"pageInfo\"&gt;Contains the information about a singular memory page.&lt;/param&gt;\n/// &lt;param name=\"bufferSize\"&gt;The size that an allocation would occupy. Pre-aligned to page-size.&lt;/param&gt;\n/// &lt;param name=\"minimumPtr\"&gt;The maximum pointer an allocation can occupy.&lt;/param&gt;\n/// &lt;param name=\"maximumPtr\"&gt;The minimum pointer an allocation can occupy.&lt;/param&gt;\n/// &lt;param name=\"results\"&gt;Span containing the results; must have at least 4 items.&lt;/param&gt;\n/// &lt;returns&gt;Zero if the operation fails; otherwise positive value.&lt;/returns&gt;\nprivate static Span&lt;nuint&gt; GetBufferPointersInPageRange(ref MEMORY_BASIC_INFORMATION pageInfo, int bufferSize, nuint minimumPtr,\n    nuint maximumPtr, Span&lt;nuint&gt; results)\n{\n    nuint pageStart = pageInfo.BaseAddress;\n    nuint pageEnd = pageInfo.BaseAddress + pageInfo.RegionSize;\n    int allocationGranularity = Cached.GetAllocationGranularity();\n    return GetPossibleBufferAddresses(minimumPtr, maximumPtr, pageStart, pageEnd, (nuint) bufferSize, allocationGranularity, results);\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n// Note: Uses C++20\n#include &lt;span&gt;\n\nstd::span&lt;uintptr_t&gt; GetBufferPointersInPageRange(MEMORY_BASIC_INFORMATION&amp; pageInfo, int bufferSize, uintptr_t minimumPtr, uintptr_t maximumPtr, std::span&lt;uintptr_t&gt;&amp; results)\n{\n    uintptr_t pageStart = pageInfo.BaseAddress;\n    uintptr_t pageEnd = pageInfo.BaseAddress + pageInfo.RegionSize;\n    int allocationGranularity = GetAllocationGranularity();\n    return GetPossibleBufferAddresses(minimumPtr, maximumPtr, pageStart, pageEnd, static_cast&lt;uintptr_t&gt;(bufferSize), allocationGranularity, results);\n}\n\nbool TryAllocateBuffer(Kernel32&amp; k32, MEMORY_BASIC_INFORMATION&amp; pageInfo, BufferAllocatorSettings&amp; settings, LocatorItem&amp; result)\n{\n    result = LocatorItem(0, 0);\n    if (pageInfo.State != MEM_STATE::FREE)\n        return false;\n\n    std::array&lt;uintptr_t, 4&gt; resultArray;\n    std::span&lt;uintptr_t&gt; results(resultArray);\n    for (auto addr : GetBufferPointersInPageRange(pageInfo, static_cast&lt;int&gt;(settings.Size), settings.MinAddress, settings.MaxAddress, results))\n    {\n        // Can redirect to VirtualAllocEx if target is another process.\n        uintptr_t allocated = k32.VirtualAlloc(addr, static_cast&lt;uintptr_t&gt;(settings.Size));\n        if (allocated == 0)\n            continue;\n\n        // Sanity test in case of '0' value input and random address allocated.\n        if (allocated != addr)\n        {\n            k32.VirtualFree(allocated, 0);\n            continue;\n        }\n\n        result = LocatorItem(allocated, settings.Size);\n        return true;\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"specification/allocation-algorithm/#linux_1","title":"Linux","text":"C#C++ <pre><code>private static bool TryAllocateBuffer(MemoryMapEntry entry, BufferAllocatorSettings settings, out LocatorItem result)\n{\n    result = default;\n\n    Span&lt;nuint&gt; results = stackalloc nuint[4];\n    foreach (var addr in GetPossibleBufferAddresses(settings.MinAddress, settings.MaxAddress, entry.StartAddress, entry.EndAddress, settings.Size, Cached.GetAllocationGranularity(), results))\n    {\n        // MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED_NOREPLACE = 0x100022\n        nint allocated = Posix.mmap(addr, (nuint)settings.Size, (int)MemoryProtection.ReadWriteExecute, 0x100022, -1, 0);\n        if (allocated == -1)\n            continue;\n\n        // Error handling for older kernels before 2018 that don't respect MAP_FIXED_NOREPLACE.\n        if ((nuint)allocated != addr)\n        {\n            Posix.munmap((nuint)allocated, settings.Size);\n            continue;\n        }\n\n        result = new LocatorItem((nuint)allocated, settings.Size);\n        return true;\n    }\n\n    return false;\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n// Note: Uses C++20\n#include &lt;sys/mman.h&gt;\n#include &lt;array&gt;\n\nbool TryAllocateBuffer(const MemoryMapEntry&amp; entry, const BufferAllocatorSettings&amp; settings, LocatorItem&amp; result)\n{\n    result = LocatorItem(0, 0);\n\n    std::array&lt;uintptr_t, 4&gt; resultArray;\n    std::span&lt;uintptr_t&gt; results(resultArray);\n    for (auto addr : GetPossibleBufferAddresses(settings.MinAddress, settings.MaxAddress, entry.StartAddress, entry.EndAddress, settings.Size, GetAllocationGranularity(), results))\n    {\n        intptr_t allocated = mmap(reinterpret_cast&lt;void*&gt;(addr), settings.Size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED_NOREPLACE, -1, 0);\n        if (allocated == reinterpret_cast&lt;intptr_t&gt;(MAP_FAILED))\n            continue;\n\n        // Error handling for older kernels before 2018 that don't respect MAP_FIXED_NOREPLACE.\n        if (static_cast&lt;uintptr_t&gt;(allocated) != addr)\n        {\n            munmap(reinterpret_cast&lt;void*&gt;(allocated), settings.Size);\n            continue;\n        }\n\n        result = LocatorItem(static_cast&lt;uintptr_t&gt;(allocated), settings.Size);\n        return true;\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"specification/allocation-algorithm/#osx_1","title":"OSX","text":"C#C++ <pre><code>private static unsafe bool TryAllocateBuffer(nuint pageAddress, nuint pageSize,\n    BufferAllocatorSettings settings, nuint selfTask, out LocatorItem result)\n{\n    result = default;\n    Span&lt;nuint&gt; results = stackalloc nuint[4];\n    foreach (var addr in GetBufferPointersInPageRange(pageAddress, pageSize, (int)settings.Size, settings.MinAddress, settings.MaxAddress, results))\n    {\n        int kr = mach_vm_allocate(selfTask, (nuint)(&amp;addr), settings.Size, 0);\n\n        if (kr != 0)\n            continue;\n\n        result = new LocatorItem(addr, settings.Size);\n        return true;\n    }\n\n    return false;\n}\n</code></pre> <pre><code>bool TryAllocateBuffer(mach_vm_address_t pageAddress, mach_vm_size_t pageSize, \n    BufferAllocatorSettings settings, mach_port_t selfTask, LocatorItem&amp; result)\n{\n    // results is replaced with a vector because stack allocated arrays are not commonly used in C++\n    std::vector&lt;mach_vm_address_t&gt; results(4);\n    for(auto addr : GetBufferPointersInPageRange(pageAddress, pageSize, static_cast&lt;int&gt;(settings.size), settings.minAddress, settings.maxAddress, results))\n    {\n        kern_return_t kr = mach_vm_allocate(selfTask, &amp;addr, settings.size, 0);\n\n        if (kr != KERN_SUCCESS)\n            continue;\n\n        result = {addr, settings.size};\n        return true;\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"specification/allocation-algorithm/#checking-if-buffer-fits","title":"Checking if Buffer Fits","text":"<p>For any memory page returned from the OS, we need to check if it satisfies our constraints.</p> C#C++ <pre><code>internal static Span&lt;nuint&gt; GetPossibleBufferAddresses(nuint minimumPtr, nuint maximumPtr, nuint pageStart, nuint pageEnd,\n    nuint bufSize, int allocationGranularity, Span&lt;nuint&gt; results)\n{\n    // Get range for page and min-max region.\n    var minMaxRange = new AddressRange(minimumPtr, maximumPtr);\n    var pageRange = new AddressRange(pageStart, pageEnd);\n\n    // Check if there is any overlap at all.\n    if (!pageRange.Overlaps(minMaxRange))\n        return default;\n\n    // Three possible cases here:\n    //   1. Page fits entirely inside min-max range and is smaller.\n    if (bufSize &gt; pageRange.Size)\n        return default; // does not fit.\n\n    int numItems = 0;\n\n    // Note: We have to test aligned to both page boundaries and min-max range boundaries;\n    //       because, they may not perfectly overlap, e.g. min-max may be way greater than\n    //       page size, so testing from start/end of that will not even overlap with available pages.\n    //       Or the opposite can happen... min-max range may be smaller than page size.\n\n    //   2. Min-max range is inside page, test aligned to page boundaries.\n\n    // Round up from page min.\n    nuint pageMinAligned = RoundUp(pageRange.StartPointer, allocationGranularity);\n    var pageMinRange = new AddressRange(pageMinAligned, AddWithOverflowCap(pageMinAligned, bufSize));\n\n    if (pageRange.Contains(pageMinRange) &amp;&amp; minMaxRange.Contains(pageMinRange))\n        results.DangerousGetReferenceAt(numItems++) = pageMinRange.StartPointer;\n\n    // Round down from page max.\n    nuint pageMaxAligned = RoundDown(SubtractWithUnderflowCap(pageRange.EndPointer, bufSize), allocationGranularity);\n    var pageMaxRange = new AddressRange(pageMaxAligned, pageMaxAligned + bufSize);\n\n    if (pageRange.Contains(pageMaxRange) &amp;&amp; minMaxRange.Contains(pageMaxRange))\n        results.DangerousGetReferenceAt(numItems++) = pageMaxRange.StartPointer;\n\n    //   3. Min-max range is inside page, test aligned to Min-max range.\n\n    // Round up from ptr min.\n    nuint ptrMinAligned = RoundUp(minimumPtr, allocationGranularity);\n    var ptrMinRange = new AddressRange(ptrMinAligned, AddWithOverflowCap(ptrMinAligned, bufSize));\n\n    if (pageRange.Contains(ptrMinRange) &amp;&amp; minMaxRange.Contains(ptrMinRange))\n        results.DangerousGetReferenceAt(numItems++) = ptrMinRange.StartPointer;\n\n    // Round down from ptr max.\n    nuint ptrMaxAligned = RoundDown(SubtractWithUnderflowCap(maximumPtr, bufSize), allocationGranularity);\n    var ptrMaxRange = new AddressRange(ptrMaxAligned, ptrMaxAligned + bufSize);\n\n    if (pageRange.Contains(ptrMaxRange) &amp;&amp; minMaxRange.Contains(ptrMaxRange))\n        results.DangerousGetReferenceAt(numItems++) = ptrMaxRange.StartPointer;\n\n    return results.SliceFast(0, numItems);\n}\n\n/// &lt;summary&gt;\n///     Defines a physical address range with a minimum and maximum address.\n/// &lt;/summary&gt;\ninternal readonly struct AddressRange\n{\n    public readonly nuint StartPointer;\n    public readonly nuint EndPointer;\n    public nuint Size =&gt; EndPointer - StartPointer;\n\n    public AddressRange(nuint startPointer, nuint endPointer)\n    {\n        StartPointer = startPointer;\n        EndPointer = endPointer;\n    }\n\n    /// &lt;summary&gt;\n    ///     Returns true if the other address range is completely inside\n    ///     the current address range.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"otherRange\"&gt;True if this address range is contained entirely inside the other.&lt;/param&gt;\n    public bool Contains(in AddressRange otherRange)\n        =&gt; otherRange.StartPointer &gt;= StartPointer &amp;&amp; otherRange.EndPointer &lt;= EndPointer;\n\n    /// &lt;summary&gt;\n    ///     Returns true if the other address range intersects this address range, i.e.\n    ///     start or end of this range falls inside other range.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"otherRange\"&gt;Returns true if there are any overlaps in the address ranges.&lt;/param&gt;\n    public bool Overlaps(in AddressRange otherRange)\n    {\n        if (PointInRange(otherRange, StartPointer)) return true;\n        if (PointInRange(otherRange, EndPointer)) return true;\n        if (PointInRange(this, otherRange.StartPointer)) return true;\n        if (PointInRange(this, otherRange.EndPointer)) return true;\n\n        return false;\n    }\n\n    /// &lt;summary&gt;\n    ///     Returns true if a number \"point\", is between min and max of address range.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"range\"&gt;Range inside which to test the point.&lt;/param&gt;\n    /// &lt;param name=\"point\"&gt;The point to test.&lt;/param&gt;\n    private bool PointInRange(in AddressRange range, nuint point)\n        =&gt; point &gt;= range.StartPointer &amp;&amp; point &lt;= range.EndPointer;\n}\n</code></pre> <pre><code>// Disclaimer: This code was ported by AI, then cleaned up by human. Not tested.\n// Note: Uses C++20\n#include &lt;cstddef&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n#include &lt;span&gt;\n\nstruct AddressRange {\n    uintptr_t StartPointer;\n    uintptr_t EndPointer;\n\n    /**\n     * Returns the size of the address range.\n     */\n    uintptr_t Size() const { return EndPointer - StartPointer; }\n\n    /**\n     * Constructor for AddressRange.\n     * @param startPointer - Start of the address range.\n     * @param endPointer - End of the address range.\n     */\n    AddressRange(uintptr_t startPointer, uintptr_t endPointer) : StartPointer(startPointer), EndPointer(endPointer) {}\n\n    /**\n     * Checks if this address range contains the other address range.\n     * @param otherRange - The other address range to check.\n     * @return true if this address range contains the other, false otherwise.\n     */\n    bool Contains(const AddressRange&amp; otherRange) const {\n        return otherRange.StartPointer &gt;= StartPointer &amp;&amp; otherRange.EndPointer &lt;= EndPointer;\n    }\n\n    /**\n     * Checks if this address range overlaps with the other address range.\n     * @param otherRange - The other address range to check.\n     * @return true if the address ranges overlap, false otherwise.\n     */\n    bool Overlaps(const AddressRange&amp; otherRange) const {\n        return PointInRange(otherRange, StartPointer) || PointInRange(otherRange, EndPointer)\n            || PointInRange(*this, otherRange.StartPointer) || PointInRange(*this, otherRange.EndPointer);\n    }\n\nprivate:\n    /**\n     * Checks if a point is within an address range.\n     * @param range - The address range to check.\n     * @param point - The point to check.\n     * @return true if the point is in the range, false otherwise.\n     */\n    bool PointInRange(const AddressRange&amp; range, uintptr_t point) const {\n        return point &gt;= range.StartPointer &amp;&amp; point &lt;= range.EndPointer;\n    }\n};\n\n/**\n * Rounds up a number to the nearest multiple.\n * @param number - The number to round up.\n * @param multiple - The multiple to round up to.\n * @return The rounded up number.\n*/\nuintptr_t RoundUp(uintptr_t number, int multiple) {\n    return ((number + multiple - 1) / multiple) * multiple;\n}\n\n/**\n* Rounds down a number to the nearest multiple.\n* @param number - The number to round down.\n* @param multiple - The multiple to round down to.\n* @return The rounded down number.\n*/\nuintptr_t RoundDown(uintptr_t number, int multiple) {\n    return (number / multiple) * multiple;\n}\n\n/**\n* Adds two numbers and caps the result to UINTPTR_MAX to prevent overflow.\n* @param a - The first number.\n* @param b - The second number.\n* @return The sum of the two numbers, capped at UINTPTR_MAX if there would be an overflow.\n*/\nuintptr_t AddWithOverflowCap(uintptr_t a, uintptr_t b) {\n    if (a &gt; UINTPTR_MAX - b) return UINTPTR_MAX;\n    else return a + b;\n}\n\n/**\n* Subtracts two numbers and makes the result 0 if it is going to underflow.\n* @param a - The first number.\n* @param b - The second number.\n* @return The subtraction of the two numbers, with value 0 if there would be an underflow.\n*/\nuintptr_t SubtractWithUnderflowCap(uintptr_t a, uintptr_t b)\n{\n    return b &lt;= a ? a - b : 0;\n}\n\n/**\n* Retrieves all locations could be allocated in given a page and address range.\n* @param minimumPtr - The minimum possible address for the buffer.\n* @param maximumPtr - The maximum possible address for the buffer.\n* @param pageStart - The start of the page.\n* @param pageEnd - The end of the page.\n* @param bufSize - The size of the buffer.\n* @param allocationGranularity - The allocation granularity.\n* @param results - Stores possible locations of the buffer, must be at least 4 elements long.\n* @return All possible locations for the buffer.\n*/\nstd::span&lt;uintptr_t&gt; GetPossibleBufferAddresses(\n    uintptr_t minimumPtr, uintptr_t maximumPtr,\n    uintptr_t pageStart, uintptr_t pageEnd,\n    uintptr_t bufSize, int allocationGranularity,\n    std::span&lt;uintptr_t&gt; results)\n{\n    // Get range for page and min-max region.\n    AddressRange minMaxRange(minimumPtr, maximumPtr);\n    AddressRange pageRange(pageStart, pageEnd);\n\n    // Check if there is any overlap at all.\n    if (!pageRange.Overlaps(minMaxRange))\n        return std::span&lt;uintptr_t&gt;();\n\n    // Three possible cases here:\n    //   1. Page fits entirely inside min-max range and is smaller.\n    if (bufSize &gt; pageRange.Size())\n        return std::span&lt;uintptr_t&gt;();\n\n    int numItems = 0;\n\n    // Note: We have to test aligned to both page boundaries and min-max range boundaries;\n    //       because, they may not perfectly overlap, e.g. min-max may be way greater than\n    //       page size, so testing from start/end of that will not even overlap with available pages.\n    //       Or the opposite can happen... min-max range may be smaller than page size.\n\n    //   2. Min-max range is inside page, test aligned to page boundaries.\n    // Round up from page min.\n    uintptr_t pageMinAligned = RoundUp(pageRange.StartPointer, allocationGranularity);\n    AddressRange pageMinRange(pageMinAligned, AddWithOverflowCap(pageMinAligned, bufSize));\n\n    if (pageRange.Contains(pageMinRange) &amp;&amp; minMaxRange.Contains(pageMinRange))\n        results[numItems++] = pageMinRange.StartPointer;\n\n    // Round down from page max.\n    uintptr_t pageMaxAligned = RoundDown(SubtractWithUnderflowCap(pageRange.EndPointer, bufSize), allocationGranularity);\n    AddressRange pageMaxRange(pageMaxAligned, pageMaxAligned + bufSize);\n\n    if (pageRange.Contains(pageMaxRange) &amp;&amp; minMaxRange.Contains(pageMaxRange))\n        results[numItems++] = pageMaxRange.StartPointer;\n\n    //   3. Min-max range is inside page, test aligned to Min-max range.\n\n    // Round up from ptr min.\n    uintptr_t ptrMinAligned = RoundUp(minimumPtr, allocationGranularity);\n    AddressRange ptrMinRange(ptrMinAligned, AddWithOverflowCap(ptrMinAligned, bufSize));\n\n    if (pageRange.Contains(ptrMinRange) &amp;&amp; minMaxRange.Contains(ptrMinRange))\n        results[numItems++] = ptrMinRange.StartPointer;\n\n    // Round down from ptr max.\n    uintptr_t ptrMaxAligned = RoundDown(SubtractWithUnderflowCap(maximumPtr, bufSize), allocationGranularity);\n    AddressRange ptrMaxRange(ptrMaxAligned, ptrMaxAligned + bufSize);\n\n    if (pageRange.Contains(ptrMaxRange) &amp;&amp; minMaxRange.Contains(ptrMaxRange))\n        results[numItems++] = ptrMaxRange.StartPointer;\n\n    return results.subspan(0, numItems);\n}\n</code></pre>"},{"location":"specification/buffer-locator/","title":"Buffer Locator","text":"<p>The buffer locator is a shared region of memory dedicated to storing allocated memory regions within a target process.</p>"},{"location":"specification/buffer-locator/#structure","title":"Structure","text":"<p>Size: <code>4096 bytes</code>, to match OS page size.</p> <ul> <li>Header (16/24 bytes)  </li> <li>Items[] (fill until end of buffer)  </li> </ul> <p>Atomic access on some platforms requires word alignment, thus this header must be such that items after are aligned.</p>"},{"location":"specification/buffer-locator/#header","title":"Header","text":"<p>Size of this header is version dependent. Implementation should not use versions it doesn't recognise.</p> <p>Size: <code>16/24 bytes</code> (Version 0).</p> <ul> <li><code>u32/u64</code> This Header Address </li> <li><code>u32/u64</code> Next Locator Ptr </li> <li><code>u32</code> IsLocked </li> <li><code>u3</code> Version </li> <li><code>u5</code> Reserved  </li> <li><code>u8</code> NumItems</li> <li><code>u8</code> Reserved</li> <li><code>u8</code> Reserved</li> </ul> <p>Locks are <code>u32</code> because older .NET versions don't support <code>u8</code> atomic operations (emitting <code>cmpxchg</code> for 1 byte).</p>"},{"location":"specification/buffer-locator/#this-header-address","title":"This Header Address","text":"<p>This header is allocated using non-persistent Memory Mapped Files.</p> <p>Actual address of this header in memory. This is the address assigned by the first ever memory mapping of the file.  </p> <p>For more details, see Finding the Locator Structure.</p>"},{"location":"specification/buffer-locator/#next-locator-ptr","title":"Next Locator Ptr","text":"<p>This is the address of the next locator structure in memory.</p> <p>i.e. If this is the first locator structure, this will be the address of the second locator structure. If this value is non-null, it is assumed that the next locator structure is valid; and the current locator is full.  </p>"},{"location":"specification/buffer-locator/#is-locked","title":"Is Locked","text":"<p>This is a lock, manipulated with <code>Interlocked.CompareExchange</code> (x86 <code>cmpxchg</code>).</p> <p>This lock is taken when the locator is being modified. If the lock is taken, the code should re-assert if modifying is still necessary after taking the lock.  </p>"},{"location":"specification/buffer-locator/#version","title":"Version","text":"<p>This stores the version of the buffer in memory.</p> <p>Size: <code>3 bits</code>, (<code>0-7</code>).  </p>"},{"location":"specification/buffer-locator/#implicit-property-max-item-count","title":"Implicit Property: Max Item Count","text":"<p>Max item count is calculated as <code>(4096 - sizeof(Header)) / sizeof(Item)</code>. Rounded down, of course.  </p>"},{"location":"specification/buffer-locator/#implicit-property-is-full","title":"Implicit Property: Is Full","text":"<p>In practice for most use cases, this buffer will never be full, but just in case.</p> <p>This is true when NumItems == Max Item Count.</p>"},{"location":"specification/buffer-locator/#item","title":"Item","text":"<p>This stores region information about a single buffer.</p> <p>Size: <code>16/20 bytes</code> </p> <ul> <li><code>u32/u64</code> Base Address (<code>u64</code> if 64-bit process)  </li> <li><code>u32</code> IsTaken  </li> <li><code>u32</code> Size  </li> <li><code>u32</code> Position  </li> </ul> <p>Remaining bytes are calculated by <code>Size - Position</code>.</p> <p>IsTaken is a lock, manipulated with <code>Interlocked.CompareExchange</code> (x86 <code>cmpxchg</code>). If <code>IsTaken</code> is true, skip the current buffer and make another if necessary.</p>"},{"location":"specification/buffer-locator/#finding-the-locator-structure","title":"Finding the Locator Structure","text":"<p>The locator structure is always located at the end of the buffer.</p> <p>Locators are allocated using <code>Memory Mapped Files</code>, with predefined name. This name is: <code>/Reloaded.Memory.Buffers.MemoryBuffer, PID {processId}</code>.  </p> <p>The name starts with a backslash because this is required by some OSes based off of POSIX.</p> <p>Code below shows basic use of <code>Memory Mapped Files</code>:  </p> C# (Cross Platform)C++ (Windows)C++ (OSX &amp; LINUX) <pre><code>// Create or open the memory-mapped file\nvar name = $\"/Reloaded.Memory.Buffers.MemoryBuffer, PID {System.Environment.ProcessId}\";\n\nMemoryMappedFile mmf;\nbool previouslyExisted = true;\ntry { mmf = MemoryMappedFile.OpenExisting(name); }\ncatch (FileNotFoundException)\n{\n    mmf = MemoryMappedFile.CreateNew(name, allocationGranularity);\n    previouslyExisted = false;\n}\n\n// Access the memory-mapped file\nvar view = mmf!.CreateViewAccessor(start, length, MemoryMappedFileAccess.ReadWrite);\nvar data = (byte*)view.SafeMemoryMappedViewHandle.DangerousGetHandle();\n\n// Pointer in `data`.\n</code></pre> <pre><code>#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\n// Note: Untested AI generated code, for reference only.\n// Note: Missing error handling.\n// Construct the name\nbool previouslyExisted = true;\nint pid = GetCurrentProcessId(); // Get current process ID\nchar bufferName[256];\nsprintf_s(bufferName, sizeof(bufferName), \"/Reloaded.Memory.Buffers.MemoryBuffer, PID %d\", pid);\n\n// Open Memory Mapped File\nHANDLE hMapFile = OpenFileMappingA(\n    FILE_MAP_ALL_ACCESS,   // read/write access\n    FALSE,                 // do not inherit the name\n    bufferName);           // name of mapping object\n\nif (hMapFile == NULL) {\n    // If the file mapping object doesn't exist, create it\n    hMapFile = CreateFileMappingA(\n        INVALID_HANDLE_VALUE,    // use paging file\n        NULL,                    // default security\n        PAGE_READWRITE,          // read/write access\n        0,                       // max. object size\n        allocationGranularity,   // buffer size\n        bufferName);             // name of mapping object\n\n    previouslyExisted = false;\n}\n\n// Map the view\nvoid* data = MapViewOfFile(\n    hMapFile,   // handle to map object\n    FILE_MAP_ALL_ACCESS, // read/write permission\n    0,\n    0,\n    allocationGranularity);\n</code></pre> <pre><code>// Note: Untested AI generated code (with manual correction), for reference only.\n// This is same as C++ (Linux), except backed by a real file.\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;filesystem&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n\n// BaseDir = `/tmp/.reloaded/memory.buffers`\npreviouslyExisted = true;\nint pid = getpid(); // Get current process ID\nstd::string name = \"/Reloaded.Memory.Buffers.MemoryBuffer, PID \" + std::to_string(pid);\nstd::string filePath = BaseDir + \"/\" + name;\nstd::filesystem::create_directories(std::filesystem::path(filePath).parent_path());\npreviouslyExisted = std::filesystem::exists(filePath);\n\nfileDescriptor = open(filePath.c_str(), O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\nif (fileDescriptor &lt; 0)\n    throw std::runtime_error(\"Failed to open or create the file.\");\n\nlseek(fileDescriptor, length - 1, SEEK_SET);\nwrite(fileDescriptor, \"\", 1);\n\nData = reinterpret_cast&lt;uint8_t*&gt;(mmap(nullptr, length, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, fileDescriptor, 0));\nif (Data == MAP_FAILED)\n{\n    close(fileDescriptor);\n    throw std::runtime_error(\"Failed to memory map the file.\");\n}\n</code></pre> <p>Memory Mapped Files on Windows respect <code>allocationGranularity</code> (usually 64KiB) which you can get from <code>GetSystemInfo</code>.</p> <p>Register the remainder of that (usually 64K) buffer after header as first Items in the locator.</p> <p>On Linux &amp; OSX we bind to real files; we use directory <code>/tmp/.reloaded/memory.buffers</code> for this, because on OSX there is no way to query open files to prevent memory leaks after crashes; and on Linux; some kernels don't allow executable shared memory objects.</p> <p>For the users implementing from other languages, here are the raw OS APIs for reference:  </p> Platform APIs Windows <code>CreateFileMapping</code>, <code>OpenFileMapping</code>, <code>MapViewOfFile</code>, <code>UnmapViewOfFile</code> Linux &amp; OSX (Posix) <code>open</code>, <code>close</code>, <code>mmap</code>, <code>munmap</code> <p>Notice the presence of <code>previouslyExisted</code> bool. This is used to determine if the locator structure needs to be kept alive.</p> <p>Here's what to do depending on situation:  </p> Memory File Not Previously ExistedMemory Mapped File Previously Existed <ul> <li>Initialize This Header Address, with current address.  </li> <li>Do not unmap file, keep it alive, forever.  </li> </ul> <ul> <li>Fetch This Header Address, and cache into static field.  </li> <li>Unmap the memory mapped file.  </li> <li>Use address from static field (address of first memory map) in this and further accesses.  </li> </ul> <p>The code for this might look something like the following:</p> C#C++ <pre><code>/// &lt;summary&gt;\n///     Retrieves the address of the first locator.\n/// &lt;/summary&gt;\n/// &lt;returns&gt;Address of the first locator.&lt;/returns&gt;\n/// &lt;exception cref=\"PlatformNotSupportedException\"&gt;This operation is not supported on the current platform.&lt;/exception&gt;\ninternal static LocatorHeader* Find()\n{\n    if (s_locatorHeaderAddress != (LocatorHeader*)0)\n        return s_locatorHeaderAddress;\n\n    // Create or open the memory-mapped file\n    IMemoryMappedFile mmf = OpenOrCreateMemoryMappedFile();\n\n    // If the MMF previously existed, we need to read the real address from the header, then close\n    // our mapping.\n    if (mmf.AlreadyExisted)\n    {\n        s_locatorHeaderAddress = ((LocatorHeader*)mmf.Data)-&gt;ThisAddress;\n        mmf.Dispose();\n        return s_locatorHeaderAddress;\n    }\n\n    Cleanup();\n    s_mmf = mmf;\n    s_locatorHeaderAddress = (LocatorHeader*)mmf.Data;\n    s_locatorHeaderAddress-&gt;Initialize(mmf.Length);\n    return s_locatorHeaderAddress;\n}\n</code></pre> <pre><code>// Note: Untested AI generated code (with manual correction), for reference only.\n// See original source in repo for implementation of OpenOrCreateMemoryMappedFile for different platforms.\nLocatorHeader* Find()\n{\n    if (s_locatorHeaderAddress != nullptr)\n        return s_locatorHeaderAddress;\n\n    // Create or open the memory-mapped file\n    MemoryMappedFile* mmf = OpenOrCreateMemoryMappedFile();\n\n    // If the MMF previously existed, we need to read the real address from the header, then close\n    // our mapping.\n    if (mmf-&gt;AlreadyExisted)\n    {\n        s_locatorHeaderAddress = reinterpret_cast&lt;LocatorHeader*&gt;(mmf-&gt;Data)-&gt;ThisAddress;\n        delete mmf;\n        return s_locatorHeaderAddress;\n    }\n\n    Cleanup();\n    s_mmf = mmf;\n    s_locatorHeaderAddress = reinterpret_cast&lt;LocatorHeader*&gt;(mmf-&gt;Data);\n    s_locatorHeaderAddress-&gt;Initialize(mmf-&gt;Length);\n    return s_locatorHeaderAddress;\n}\n</code></pre>"},{"location":"specification/buffer-locator/#cleaning-up","title":"Cleaning Up","text":"<p>On Linux &amp; OSX, Shared Memory Objects are NOT automatically destroyed when all processes close.</p> <p>Given expected use is in hooking frameworks where crashes are expected to be common on dev machines.</p> <p>In these scenarios, we cannot waste memory. For both OSX and Linux, we look through <code>/tmp/.reloaded/memory.buffers</code> for any unused mapping, and delete/unlink them.</p> <p>In the reference library, the following code is ran upon successful opening of existing memory mapped file (i.e. only ever once per library instance).  </p> C#C++ <pre><code>private static void Cleanup()\n{\n    // Keep the view around forever for other modThjers/programs/etc. to use.\n\n    // Note: At runtime this is only ever executed once per library instance, so this should be okay.\n    // On Linux and OSX we need to execute a runtime check to ensure that after a crash, no MMF was left over.\n    // because the OS does not auto dispose them.\n    CleanupPosix(UnixMemoryMappedFile.BaseDir, (path) =&gt;\n    {\n        try { File.Delete(path); }\n        catch (Exception) { /* Ignored */ }\n    });\n}\n\nprivate static void CleanupPosix(string mmfDirectory, Action&lt;string&gt; deleteFile)\n{\n    const string memoryMappedFilePrefix = \"Reloaded.Memory.Buffers.MemoryBuffer, PID \";\n    var files = Directory.EnumerateFiles(mmfDirectory);\n\n    foreach (var file in files)\n    {\n        var fileName = Path.GetFileName(file);\n        if (!fileName.StartsWith(memoryMappedFilePrefix))\n            continue;\n\n        // Extract PID from the file name\n        var pidStr = fileName.Substring(memoryMappedFilePrefix.Length);\n        if (!int.TryParse(pidStr, out var pid))\n            continue;\n\n        // Check if the process is still running\n        if (!IsProcessRunning(pid))\n            deleteFile(fileName);\n    }\n}\n\nprivate static bool IsProcessRunning(int pid)\n{\n    try\n    {\n        Process.GetProcessById(pid);\n        return true;\n    }\n    catch (ArgumentException)\n    {\n        // Process is not running\n        return false;\n    }\n}\n</code></pre> <pre><code>// AI Generated.\n// Note: This is untested code, for reference only.\n// Note: This will only build on a Linux/OSX box due to included headers. You'll need to compile guard this.\n#include &lt;dirent.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdlib&gt;\n#include &lt;pwd.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/mman.h&gt;\n\nvoid Cleanup();\nvoid CleanupPosix(const std::string&amp; mmfDirectory);\nbool IsProcessRunning(pid_t pid);\n\nvoid Cleanup() {\n    CleanupPosix(\"/tmp/.reloaded/memory.buffers\");\n}\n\nvoid CleanupPosix(const std::string&amp; mmfDirectory) {\n    const std::string memoryMappedFilePrefix = \"Reloaded.Memory.Buffers.MemoryBuffer, PID \";\n\n    DIR *dir;\n    struct dirent *ent;\n    struct stat st;\n\n    if ((dir = opendir(mmfDirectory.c_str())) != nullptr) {\n        while ((ent = readdir(dir)) != nullptr) {\n            std::string fileName = ent-&gt;d_name;\n\n            if (fileName.find(memoryMappedFilePrefix) != 0)\n                continue;\n\n            std::string pidStr = fileName.substr(memoryMappedFilePrefix.length());\n            pid_t pid = std::stoi(pidStr);\n\n            if (!IsProcessRunning(pid)) {\n                std::string filePath = mmfDirectory + \"/\" + fileName;\n                std::remove(filePath.c_str());\n            }\n        }\n        closedir(dir);\n    } else {\n        perror(\"\");\n    }\n}\n\nbool IsProcessRunning(pid_t pid) {\n    return kill(pid, 0) == 0;\n}\n</code></pre>"},{"location":"specification/buffer-locator/#supporting-concurrency","title":"Supporting Concurrency","text":"<p>Only one user may use a buffer at any time.</p> <p>Access to all buffers should look something like:  </p> <pre><code>// Ensure safe disposal of buffer \n// - `using` in C#\n// - RAII in C++\n// - Drop trait in Rust\n// etc.\nusing var buffer = BufferHelper.GetOrAllocateBuffer(minAddress, maxAddress, size);\n</code></pre> <p>When the buffer is acquired, a the IsTaken field is set to <code>1</code> using <code>cmpxchg</code>.  </p> <pre><code>// C#\nitem-&gt;IsTaken = Interlocked.CompareExchange(ref item-&gt;IsTaken, 1, 0);\n</code></pre> <p>When the buffer is released, the <code>IsTaken</code> field is set to <code>0</code>.  </p> <pre><code>item-&gt;IsTaken = 0;\n</code></pre>"},{"location":"specification/buffer-locator/#allocating-buffers","title":"Allocating Buffers","text":"<p>Allocation algorithm is documented here</p> <p>Use C# high level API (detailed in usage) for additional reference.</p> <p>If an additional buffer requires to be allocated, the following steps are taken:</p> <ul> <li>If an existing buffer is not taken, and has sufficient space, lock it and use it.  </li> </ul> <p>or...</p> <ul> <li>If no unlocked buffer exists, and <code>header.NumItems</code> &lt; MaxItemCount, allocate a new buffer.  <ul> <li>Lock the allocator structure.  </li> <li>Allocate memory (multiple of 4096 sufficient to fit content).  </li> <li>Write buffer to end of header and increment <code>NumItems</code>.</li> </ul> </li> </ul> <p>or...</p> <ul> <li>If no unlocked buffer exists, and <code>header.NumItems</code> &gt;= MaxItemCount...</li> </ul> Next Locator Ptr is 0Next Locator Ptr is not 0 <ul> <li>Allocate new locator (malloc 4096 bytes) and initialize header.  </li> <li>Initialize new locator. </li> <li>Assign Next Locator Ptr.  </li> <li>Operate on [Next Locator Ptr]</li> </ul> <ul> <li>Visit Next Locator Ptr and try finding an unlocked buffer.</li> </ul> <p>In practice, it's expected another locator will probably never be allocated.</p>"},{"location":"specification/overview/","title":"Buffers Specification","text":"<p>Version 1.0.0 (Library Version 3.0.0+)</p> <p><code>Reloaded.Memory.Buffers</code> is a library for allocating memory between a given minimum and maximum memory address</p> <p>With the following properties:  </p> <ul> <li>Memory Efficient: No wasted memory.  </li> <li>Shared: Can be found and read/written to by multiple users.  </li> <li>Static: Allocated data never moves, or is overwritten.  </li> <li>Permanent: Allocated data lasts the lifetime of the process.  </li> <li>Concurrent: Multiple users can access at the same time.  </li> <li>Large Address Aware: On Windows, the library can correctly leverage all 4GB in 32-bit processes.  </li> </ul>"},{"location":"specification/overview/#use-cases","title":"Use Cases","text":"<p>These are just examples.</p> <ul> <li>Hooks: Hooking libraries like Reloaded.Hooks can reduce amount of bytes stolen from functions.  </li> <li>Libraries: Libraries like Reloaded.Assembler require memory be allocated in first 2GB.  </li> </ul> <p>And some other useful functionality.</p>"},{"location":"specification/overview/#field-sizes","title":"Field Sizes","text":"<p>Field sizes used used in this spec are based on Rust notation; with some custom types e.g.</p> <ul> <li><code>u8</code>: Unsigned 8 bits.</li> <li><code>i8</code>: Signed 8 bits.</li> <li><code>u4</code>: 4 bits.</li> <li><code>u32/u64</code>: 4 Bytes or 8 Bytes (depending on variant).</li> </ul> <p>Assume any bit packed values are sequential, i.e. if <code>u4</code> then <code>u4</code> is specified, first <code>u4</code> is the upper 4 bits.</p> <p>All packed fields are <code>little-endian</code>; and written out when total number of bits aligns with a power of 2.</p> <ul> <li><code>u6</code> + <code>u12</code> is 2 bytes <code>little-endian</code></li> <li><code>u15</code> + <code>u17</code> is 4 bytes <code>little-endian</code></li> <li><code>u26</code> + <code>u22</code> + <code>u16</code> is 8 bytes <code>little-endian</code></li> <li><code>u6</code> + <code>u11</code> + <code>u17</code> is 4 bytes <code>little-endian</code>, not 2+2</li> </ul>"},{"location":"specification/overview/#general-access-pattern","title":"General Access Pattern","text":"<p>Names below are not final API, only for illustration purposes.</p> <pre><code>flowchart TB\n  User[\"User\"] --&gt; GetOrAllocateBuffer([\"Buffers.GetBuffer\"])\n  GetOrAllocateBuffer --&gt; BufferLocatorFind([\"LocatorHeaderFinder.Find\"])\n  BufferLocatorFind -- \"(Via Memory Mapped Files)\" --&gt; GetAvailableItem([\"LocatorHeader.GetFirstAvailableItem(locator)\"])\n  GetAvailableItem --&gt; BufferMatch{Buffer Match Found?}\n  BufferMatch -- Yes --&gt; ReturnBufferToUser[\"Lock &amp; Return Buffer to User\"]\n  BufferMatch -- \"No (Make New Buffer)\" --&gt; CanRegisterBuffer{Locator Has Space for New Entry?}\n  CanRegisterBuffer -- \"No (Alloc New Locator, Link via Pointer &amp; Try Again)\" --&gt; GetAvailableItem\n  CanRegisterBuffer -- \"Yes (Allocate Memory and Register)\" --&gt; BufferAllocator([\"BufferAllocator.Allocate\"])\n  BufferAllocator -- \"Lock &amp; Register Returned Buffer\" --&gt; BufferLocatorRegister([\"LocatorHeader.Register\"])\n  BufferLocatorRegister --&gt; ReturnNewBufferToUser[\"Return New Buffer to User\"]</code></pre> <p>In the flowchart above, the user calls <code>GetBuffer</code>, which in turn calls <code>LocatorHeaderFinder.Find</code> to get address of the locator structure.</p> <p>If a match is found (Yes path), the buffer is locked and then returned to the user. </p> <p>If no match is found (No path), a new buffer is allocated, and locked. If this buffer can fit into the current locator, it is appended. Otherwise a new locator is allocated (linked via pointer), and the buffer is registered into the new locator. Buffer is then returned to the user.</p>"}]}